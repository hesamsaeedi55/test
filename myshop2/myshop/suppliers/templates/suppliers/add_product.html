{% load static %}
{% load i18n %}
<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% trans "Add Product" %}</title>
    
    <!-- External Libraries -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    <script src="https://unpkg.com/browser-image-compression@2.0.2/dist/browser-image-compression.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>
    
    <!-- Custom Styles -->
    <link rel="stylesheet" href="{% static 'suppliers/templates/suppliers/add_product/styles/main.css' %}">
    <link rel="stylesheet" href="{% static 'suppliers/templates/suppliers/add_product/styles/ProductInfoForm.css' %}">
    <link rel="stylesheet" href="{% static 'suppliers/templates/suppliers/add_product/styles/CategoryTagsForm.css' %}">
    <link rel="stylesheet" href="{% static 'suppliers/templates/suppliers/add_product/styles/VariantsForm.css' %}">
    
    <!-- Magnificent Drag-and-Drop Styles -->
    <style>
        .sortable-ghost {
            opacity: 0.5;
            background: rgba(49, 130, 206, 0.1);
            border: 2px dashed #3182ce;
            transform: scale(0.98);
            transition: all 0.2s ease;
        }
        
        .sortable-chosen {
            transform: scale(1.02);
            box-shadow: 0 4px 15px rgba(49, 130, 206, 0.3);
            z-index: 1000;
            transition: none !important;
        }
        
        .sortable-drag {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
            z-index: 1001;
            transition: none !important;
        }
        
        .preview-item {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }
        
        .preview-item:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        
        .preview-item.dragging {
            opacity: 0.6;
            transform: scale(1.1) rotate(5deg);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }
        
        .preview-item.draggable {
            cursor: move;
        }
        
        .preview-item.draggable:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        
        .image-preview.drag-over {
            border-color: #3182ce;
            background: rgba(49, 130, 206, 0.1);
        }
        
        .preview-item.drop-target {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(49, 130, 206, 0.8);
            border: 3px solid #3182ce;
            background: rgba(49, 130, 206, 0.2);
            animation: pulse-glow 1s ease-in-out infinite alternate;
        }
        
        @keyframes pulse-glow {
            0% {
                box-shadow: 0 0 20px rgba(49, 130, 206, 0.8);
                border-color: #3182ce;
            }
            100% {
                box-shadow: 0 0 30px rgba(49, 130, 206, 1);
                border-color: #60a5fa;
            }
        }
        
        .image-preview {
            min-height: 200px;
            padding: 20px;
            border: 2px dashed #4a5568;
            border-radius: 8px;
            background: rgba(45, 55, 72, 0.3);
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: flex-start;
            position: relative;
        }
        
        .image-preview.sortable-container {
            user-select: none;
        }
        
        .image-preview:empty::before {
            content: "ØªØµØ§ÙˆÛŒØ± Ø§Ù†ØªØ®Ø§Ø¨ Ø´Ø¯Ù‡ Ø§ÛŒÙ†Ø¬Ø§ Ù†Ù…Ø§ÛŒØ´ Ø¯Ø§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯ - Ø¨Ø±Ø§ÛŒ ØªØºÛŒÛŒØ± ØªØ±ØªÛŒØ¨ØŒ ØªØµØ§ÙˆÛŒØ± Ø±Ø§ Ø¨Ú©Ø´ÛŒØ¯";
            display: block;
            text-align: center;
            color: #a0aec0;
            font-style: italic;
            padding: 40px;
            width: 100%;
        }
        
        /* Drop zone indicators */
        .sortable-ghost::before {
            content: "Ø§ÛŒÙ†Ø¬Ø§ Ù‚Ø±Ø§Ø± Ø¯Ù‡ÛŒØ¯";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(49, 130, 206, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            z-index: 10;
        }
        
        /* Crop Modal Styles */
        .crop-modal {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        .crop-modal-content {
            animation: modalSlideIn 0.3s ease-out;
        }
        
        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translate(-50%, -60%);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }
        
        .crop-container {
            position: relative;
            overflow: hidden;
            border-radius: 8px;
            background: #1a202c;
        }
        
        .crop-container img {
            max-width: 100%;
            height: auto;
        }
        
        /* Cropper.js custom styles */
        .cropper-container {
            direction: ltr;
        }
        
        .cropper-modal {
            background-color: rgba(0, 0, 0, 0.5);
        }
        
        .cropper-view-box {
            outline: 2px solid #3182ce;
            outline-offset: -1px;
        }
        
        .cropper-face {
            background-color: transparent;
        }
        
        .cropper-line {
            background-color: #3182ce;
        }
        
        .cropper-point {
            background-color: #3182ce;
            width: 8px;
            height: 8px;
        }
        
        .cropper-point.point-se {
            background-color: #3182ce;
        }
        
        .cropper-point.point-sw {
            background-color: #3182ce;
        }
        
        .cropper-point.point-nw {
            background-color: #3182ce;
        }
        
        .cropper-point.point-ne {
            background-color: #3182ce;
        }
        
        .cropper-point.point-n {
            background-color: #3182ce;
        }
        
        .cropper-point.point-s {
            background-color: #3182ce;
        }
        
        .cropper-point.point-w {
            background-color: #3182ce;
        }
        
        .cropper-point.point-e {
            background-color: #3182ce;
        }
        
        /* Modern attribute selection animations */
        @keyframes pulse-selection {
            0% {
                transform: translateY(-2px) scale(1);
                box-shadow: 0 8px 25px rgba(40, 167, 69, 0.25);
            }
            50% {
                transform: translateY(-4px) scale(1.02);
                box-shadow: 0 12px 35px rgba(40, 167, 69, 0.4);
            }
            100% {
                transform: translateY(-2px) scale(1);
                box-shadow: 0 8px 25px rgba(40, 167, 69, 0.25);
            }
        }
        
        /* Enhanced grid layout for modern cards */
        .variant-attributes-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 1.5rem;
            padding: 1rem 0;
        }
    </style>
    
    <!-- Modern UI Components -->
    {% include 'suppliers/add_product/components/common/NotificationSystem.html' %}
    
    <!-- External Scripts -->
    <script src="{% static 'shop/js/product_tags.js' %}"></script>
    <script src="{% static 'shop/js/image_editor.js' %}"></script>
    
    <!-- Data Scripts -->
    <script id="category-tags-data" type="application/json">
        {{ category_tags|safe }}
    </script>
    
    <script id="selected-tags-data" type="application/json">
        {{ selected_tags|safe }}
    </script>
    
    <script id="existing-variants-data" type="application/json">
        {{ existing_variants_json|safe }}
    </script>
    
    <script id="product-images-data" type="application/json">
        {{ product_images|safe }}
    </script>
    
    <!-- Category Attributes Data -->
    <script id="category-attributes-data" type="application/json">
        {{ category_attributes|safe }}
    </script>
    
    <!-- Existing Attributes Data -->
    <script id="existing-attrs-data" type="application/json">
        {{ existing_attrs|safe }}
    </script>
</head>
<body>
    <div class="container">
        <div class="form-card">
            <div class="form-header">
                <div>
                    <h1>{% if is_edit %}ÙˆÛŒØ±Ø§ÛŒØ´ Ù…Ø­ØµÙˆÙ„{% else %}Ø§ÙØ²ÙˆØ¯Ù† Ù…Ø­ØµÙˆÙ„ Ø¬Ø¯ÛŒØ¯{% endif %}</h1>
                    <p>{% if is_edit %}Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù…Ø­ØµÙˆÙ„ Ø±Ø§ ÙˆÛŒØ±Ø§ÛŒØ´ Ú©Ù†ÛŒØ¯{% else %}Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù…Ø­ØµÙˆÙ„ Ø¬Ø¯ÛŒØ¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯{% endif %}</p>
                </div>
                <div class="header-actions">
                    <div class="form-progress">
                        <div class="progress-bar">
                            <div class="progress-fill" id="formProgress" style="width: 0%"></div>
                        </div>
                        <span class="progress-text" id="progressText">0% ØªÚ©Ù…ÛŒÙ„ Ø´Ø¯Ù‡</span>
                </div>
                <div class="theme-toggle" onclick="toggleTheme()">
                    <i class="theme-icon">ğŸŒ™</i>
                    <span>ØªØºÛŒÛŒØ± ØªÙ…</span>
                    </div>
                </div>
            </div>

            <!-- Messages Display Area -->
            {% if messages %}
            <div class="messages-container" style="margin-bottom: 20px;">
                {% for message in messages %}
                <div class="alert alert-{{ message.tags }}" style="padding: 12px; border-radius: 4px; margin-bottom: 10px; {% if message.tags == 'success' %}background: #d4edda; color: #155724; border: 1px solid #c3e6cb;{% elif message.tags == 'error' %}background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb;{% else %}background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb;{% endif %}">
                    {{ message }}
                </div>
                {% endfor %}
            </div>
            {% endif %}

            <!-- Form Errors Display Area -->
            {% if form.errors %}
            <div class="error-summary" style="margin-bottom: 20px; padding: 15px; background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; border-radius: 4px;">
                <h4 style="margin: 0 0 10px 0; color: #721c24;">Ù„Ø·ÙØ§ Ø®Ø·Ø§Ù‡Ø§ÛŒ Ø²ÛŒØ± Ø±Ø§ Ø§ØµÙ„Ø§Ø­ Ú©Ù†ÛŒØ¯:</h4>
                {{ form.non_field_errors }}
                {% for field in form %}
                    {% if field.errors %}
                        {% for error in field.errors %}
                            <div style="margin-bottom: 5px;">
                                <strong>{{ field.label|default:field.name }}:</strong> {{ error }}
                            </div>
                        {% endfor %}
                    {% endif %}
                {% endfor %}
            </div>
            {% endif %}

            <form method="post" action="{% if product_id %}{% url 'suppliers:add_product' %}?product_id={{ product_id }}{{ supplier_query }}{% else %}{% url 'suppliers:add_product' %}{{ supplier_query }}{% endif %}" enctype="multipart/form-data" id="product_form" novalidate onsubmit="console.log('ğŸš¨ FORM ONSUBMIT TRIGGERED'); if (typeof collectImageData === 'function') { console.log('âœ… collectImageData exists, calling it...'); collectImageData(this); } else { console.error('âŒ collectImageData NOT FOUND!'); } return prepareFormSubmission(this);">
                {% csrf_token %}
                {% if is_edit %}
                <input type="hidden" name="is_edit" value="true">
                <input type="hidden" id="product_id" name="product_id" value="{{ product.id }}">
                {% endif %}
                
                <!-- DEBUG: Add a test hidden input to verify form submission -->
                <input type="hidden" name="debug_test" value="form_submitted_successfully">
                
                <div class="form-grid">
                    <!-- Include Form Components -->
                    {% include 'suppliers/add_product/components/ProductInfoForm.html' %}
                    {% include 'suppliers/add_product/components/CategoryTagsForm.html' %}
                    {% include 'suppliers/add_product/components/PricingForm.html' %}
                    {% include 'suppliers/add_product/components/InventoryForm.html' %}
                    {% include 'suppliers/add_product/components/VariantsForm_test.html' %}
                    {% include 'suppliers/add_product/components/MediaUploadForm.html' %}
                    {% include 'suppliers/add_product/components/AttributesForm.html' %}
                </div>

                <div class="submit-row">
                    <input type="submit" name="_save" value="Ø°Ø®ÛŒØ±Ù‡ Ù…Ø­ØµÙˆÙ„" class="submit-btn" onclick="console.log('ğŸ”´ SUBMIT BUTTON CLICKED'); if (typeof collectImageData === 'function') { console.log('âœ… collectImageData exists'); const form = document.getElementById('product_form'); if (form) { console.log('âœ… Form found, calling collectImageData...'); collectImageData(form); } else { console.error('âŒ Form not found!'); } } else { console.error('âŒ collectImageData NOT FOUND!'); } handleSaveClick(this); return true;">
                </div>
                
                <!-- Success notification area -->
                <div id="save-notification" style="display: none; position: fixed; top: 20px; right: 20px; background: #4CAF50; color: white; padding: 20px 30px; border-radius: 8px; box-shadow: 0 6px 20px rgba(0,0,0,0.3); z-index: 5000; font-size: 16px; font-weight: bold; border: 2px solid #45a049;">
                    âœ… Ù…Ø­ØµÙˆÙ„ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯!<br>
                    <small style="font-size: 12px; opacity: 0.9;">Ø¯Ø± Ù‡Ù…ÛŒÙ† ØµÙØ­Ù‡ Ø¨Ø§Ù‚ÛŒ Ø¨Ù…Ø§Ù†ÛŒØ¯ Ø¨Ø±Ø§ÛŒ ÙˆÛŒØ±Ø§ÛŒØ´ Ø¨ÛŒØ´ØªØ±</small>
                </div>
            </form>
        </div>
    </div>

    <script>
        // âœ… DEBUG MODE ENABLED - Console logs are active
        console.log('ğŸ¯ DEBUG MODE: All console logs are ENABLED for debugging');

        // Function to collect image data and add to form
        function collectImageData(form) {
            console.log('ğŸ” collectImageData called - START');
            const mainContainer = document.getElementById('imagePreviews');
            if (!mainContainer) {
                console.log('âš ï¸ Image preview container not found');
                return;
            }
            
            // Remove existing image data inputs
            const existingInputs = form.querySelectorAll('input[name="existing_image_ids"], input[name="existing_image_orders"], input[name="image_order"], input[name="replace_image_id"]');
            existingInputs.forEach(input => input.remove());
            console.log(`ğŸ§¹ Removed ${existingInputs.length} old image data inputs`);
            
            // Get images directly from container's children to ensure we get them in DOM order
            // This is critical - when images are dragged and reordered, the DOM order changes
            // By getting children directly, we get them in the current visual order
            // Read from live DOM, not cached
            const allChildren = Array.from(mainContainer.children);
            console.log(`ğŸ“¦ Container has ${allChildren.length} total children`);
            
            const images = allChildren.filter(child => 
                child.classList.contains('preview-item')
            );
            
            console.log(`ğŸ“¸ Found ${images.length} preview-item elements`);
            
            // Debug: Log the actual DOM order
            console.log('ğŸ” DOM order of images:');
            images.forEach((item, idx) => {
                const id = item.getAttribute('data-image-id') || 'NEW';
                console.log(`  Position ${idx + 1}: Image ID ${id}`);
            });
            
            const existingImageIds = [];
            const existingImageOrders = [];
            
            // Get the file input to know how many new files will be uploaded
            const imageInput = document.getElementById('imageInput');
            const newFilesCount = imageInput && imageInput.files ? imageInput.files.length : 0;
            
            console.log(`ğŸ“ New files to upload: ${newFilesCount}`);
            
            // Separate existing and new images
            // IMPORTANT: We iterate through images array which reflects current DOM order
            // When images are dragged and reordered, the children order changes, so we get correct order
            images.forEach((item, index) => {
                const order = index + 1; // Current position in DOM (reflects drag-and-drop order)
                const imageId = item.getAttribute('data-image-id');
                const isNewImage = !imageId || imageId === 'undefined' || imageId === 'null';
                
                if (isNewImage) {
                    // New image - will be handled by file input
                    console.log(`  ğŸ“· New image at DOM position ${order}`);
                } else {
                    // Existing image - collect its ID and current DOM position
                    existingImageIds.push(imageId);
                    existingImageOrders.push(order);
                    console.log(`  ğŸ’¾ Existing image ID ${imageId} -> order ${order} (DOM position ${index + 1})`);
                }
            });
            
            console.log(`ğŸ“‹ Final order mapping:`);
            console.log(`  - Existing image IDs: [${existingImageIds.join(', ')}]`);
            console.log(`  - Existing image orders: [${existingImageOrders.join(', ')}]`);
            
            // Verify orders match IDs
            if (existingImageIds.length !== existingImageOrders.length) {
                console.error(`âŒ ERROR: Mismatch! ${existingImageIds.length} IDs but ${existingImageOrders.length} orders`);
            }
            
            // Add hidden inputs for existing images
            if (existingImageIds.length > 0) {
                existingImageIds.forEach((id, index) => {
                    const idInput = document.createElement('input');
                    idInput.type = 'hidden';
                    idInput.name = 'existing_image_ids';
                    idInput.value = id;
                    form.appendChild(idInput);
                    
                    const orderInput = document.createElement('input');
                    orderInput.type = 'hidden';
                    orderInput.name = 'existing_image_orders';
                    orderInput.value = existingImageOrders[index];
                    form.appendChild(orderInput);
                });
                console.log(`âœ… Added ${existingImageIds.length} existing image IDs to form`);
            }
            
            // Add order inputs for files that need to be uploaded
            // This includes: new images AND existing images that were cropped
            // The backend expects image_order to match the files in all_images (one-to-one)
            if (newFilesCount > 0) {
                // Find all images that have files (new images or cropped existing images)
                const imagesWithFiles = [];
                images.forEach((item, index) => {
                    const imageId = item.getAttribute('data-image-id');
                    const isNewImage = !imageId || imageId === 'undefined' || imageId === 'null';
                    const isCropped = window.croppedFilesMap && window.croppedFilesMap.has(item);
                    
                    // This image has a file if it's new OR if it's an existing image that was cropped
                    if (isNewImage || isCropped) {
                        imagesWithFiles.push({
                            item: item,
                            position: index + 1, // position in preview (1-based, matches DOM order)
                            imageId: imageId,
                            isNewImage: isNewImage,
                            isCropped: isCropped
                        });
                    }
                });
                
                console.log(`ğŸ” Images with files: ${imagesWithFiles.length}`);
                console.log(`ğŸ“ Files to upload: ${newFilesCount}`);
                
                // Match files to image positions (files are in the same order as imagesWithFiles)
                imagesWithFiles.forEach((imageData, index) => {
                    const order = imageData.position;
                    const orderInput = document.createElement('input');
                    orderInput.type = 'hidden';
                    orderInput.name = 'image_order';
                    orderInput.value = order;
                    form.appendChild(orderInput);
                    
                    const replaceInput = document.createElement('input');
                    replaceInput.type = 'hidden';
                    replaceInput.name = 'replace_image_id';
                    // If this is a cropped existing image, set replace_image_id to the image ID
                    // Otherwise, leave it empty for new images
                    replaceInput.value = (imageData.isCropped && !imageData.isNewImage) ? imageData.imageId : '';
                    form.appendChild(replaceInput);
                    
                    if (imageData.isCropped && !imageData.isNewImage) {
                        console.log(`  ğŸ“¸ File ${index + 1} -> order ${order} (replaces existing image ID ${imageData.imageId})`);
                    } else {
                        console.log(`  ğŸ“¸ File ${index + 1} -> order ${order} (new image)`);
                    }
                });
                
                // If we have more files than images with files, add default orders
                // (This shouldn't happen normally, but handle it just in case)
                if (newFilesCount > imagesWithFiles.length) {
                    // Calculate max order from existing images and images with files
                    const allOrders = [...existingImageOrders, ...imagesWithFiles.map(d => d.position)];
                    const currentMaxOrder = allOrders.length > 0 ? Math.max(...allOrders) : 0;
                    for (let i = imagesWithFiles.length; i < newFilesCount; i++) {
                        const orderInput = document.createElement('input');
                        orderInput.type = 'hidden';
                        orderInput.name = 'image_order';
                        orderInput.value = currentMaxOrder + i - imagesWithFiles.length + 1;
                        form.appendChild(orderInput);
                        
                        const replaceInput = document.createElement('input');
                        replaceInput.type = 'hidden';
                        replaceInput.name = 'replace_image_id';
                        replaceInput.value = '';
                        form.appendChild(replaceInput);
                    }
                    console.log(`âš ï¸ Added ${newFilesCount - imagesWithFiles.length} additional default orders`);
                }
                
                console.log(`âœ… Added ${Math.min(imagesWithFiles.length, newFilesCount)} image orders for files`);
            }
            
            // Final verification: Check what's actually in the form
            const finalIdInputs = form.querySelectorAll('input[name="existing_image_ids"]');
            const finalOrderInputs = form.querySelectorAll('input[name="existing_image_orders"]');
            
            console.log(`âœ… Image data collection complete: ${existingImageIds.length} existing, ${newFilesCount} new files, ${images.length} total`);
            console.log(`ğŸ” Final verification:`);
            console.log(`  - existing_image_ids inputs in form: ${finalIdInputs.length}`);
            console.log(`  - existing_image_orders inputs in form: ${finalOrderInputs.length}`);
            
            // Log actual values that will be submitted
            const submittedIds = Array.from(finalIdInputs).map(input => input.value);
            const submittedOrders = Array.from(finalOrderInputs).map(input => input.value);
            
            console.log(`  - Submitted IDs: [${submittedIds.join(', ')}]`);
            console.log(`  - Submitted orders: [${submittedOrders.join(', ')}]`);
            
            // Verify pairing
            if (submittedIds.length === submittedOrders.length) {
                console.log(`  âœ… Verification: ${submittedIds.length} pairs will be submitted:`);
                submittedIds.forEach((id, idx) => {
                    console.log(`    Image ID ${id} -> Order ${submittedOrders[idx]}`);
                });
            } else {
                console.error(`  âŒ ERROR: Mismatch in form! ${submittedIds.length} IDs but ${submittedOrders.length} orders`);
            }
        }
        
        // âœ¨ CRITICAL: Replace cropped files before form submission
        function replaceCroppedFiles(form) {
            console.log('ğŸ”„ Checking for cropped images...');
            
            if (!window.croppedFilesMap || window.croppedFilesMap.size === 0) {
                console.log('â„¹ï¸ No cropped images found');
                return;
            }
            
            console.log(`ğŸ“¦ Found ${window.croppedFilesMap.size} cropped image(s)`);
            
            const imageInput = document.getElementById('imageInput');
            if (!imageInput) {
                console.error('âŒ Image input not found');
                return;
            }
            
            const mainContainer = document.getElementById('imagePreviews');
            if (!mainContainer) {
                console.error('âŒ Image preview container not found');
                return;
            }
            
            // Get all preview items in DOM order
            const allPreviewItems = Array.from(mainContainer.children).filter(child => 
                child.classList.contains('preview-item')
            );
            
            console.log(`ğŸ“¸ Total preview items: ${allPreviewItems.length}`);
            
            // Create a DataTransfer object to build a new FileList
            const dataTransfer = new DataTransfer();
            
            // Track which original files we've processed
            const originalFiles = imageInput.files ? Array.from(imageInput.files) : [];
            let originalFileIndex = 0;
            
            // Process each preview item in DOM order
            allPreviewItems.forEach((previewItem, index) => {
                const imageId = previewItem.getAttribute('data-image-id');
                const isNewImage = !imageId || imageId === 'undefined' || imageId === 'null';
                const isCropped = previewItem.dataset.croppedFile === 'true' || window.croppedFilesMap.has(previewItem);
                
                if (isCropped && window.croppedFilesMap.has(previewItem)) {
                    // This image was cropped - use the cropped file
                    const croppedFile = window.croppedFilesMap.get(previewItem);
                    dataTransfer.items.add(croppedFile);
                    
                    if (isNewImage) {
                        console.log(`âœ… Added cropped file for NEW image ${index + 1}: ${croppedFile.name} (${croppedFile.size} bytes)`);
                    } else {
                        console.log(`âœ… Added cropped file for EXISTING image ${index + 1} (ID: ${imageId}): ${croppedFile.name} (${croppedFile.size} bytes)`);
                    }
                } else if (isNewImage && originalFileIndex < originalFiles.length) {
                    // This is a new image that wasn't cropped - use the original file
                    const originalFile = originalFiles[originalFileIndex];
                    dataTransfer.items.add(originalFile);
                    console.log(`âœ… Added original file for new image ${index + 1}: ${originalFile.name}`);
                    originalFileIndex++;
                }
                // Existing images (with data-image-id) that weren't cropped don't need files - they're handled separately
            });
            
            // Replace the file input's files with the new FileList
            imageInput.files = dataTransfer.files;
            
            console.log(`âœ… Replaced file input with ${dataTransfer.files.length} file(s) (${window.croppedFilesMap.size} cropped)`);
        }
        
        // CRITICAL: Function called before form submission to add variant data
        function prepareFormSubmission(form) {
            console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            console.log('ğŸš€ FORM SUBMISSION STARTING');
            console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            
            try {
                // âœ¨ CRITICAL: Replace cropped files FIRST, before collecting image data
                console.log('âœ‚ï¸ Step 0: Replacing cropped files...');
                replaceCroppedFiles(form);
                
                // Collect image data first
                console.log('ğŸ“¸ Step 1: Collecting image data...');
                collectImageData(form);
                
                // Log what's in the form RIGHT before submission
                console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                console.log('ğŸ“‹ FORM DATA BEFORE SUBMISSION:');
                console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                
                const formData = new FormData(form);
                const submittedImageIds = formData.getAll('existing_image_ids');
                const submittedImageOrders = formData.getAll('existing_image_orders');
                
                console.log(`  existing_image_ids: [${submittedImageIds.join(', ')}]`);
                console.log(`  existing_image_orders: [${submittedImageOrders.join(', ')}]`);
                
                // âœ¨ ALERT - Show in a way that persists even if page reloads
                const pairing = [];
                if (submittedImageIds.length > 0 && submittedImageOrders.length > 0) {
                    console.log('  Pairing:');
                    submittedImageIds.forEach((id, idx) => {
                        if (idx < submittedImageOrders.length) {
                            const pair = `Image ID ${id} -> Order ${submittedImageOrders[idx]}`;
                            console.log(`    ${pair}`);
                            pairing.push(pair);
                        }
                    });
                } else {
                    console.error('  âŒ ERROR: No image data found in form!');
                }
                
                // Store in sessionStorage so we can see it after reload
                if (pairing.length > 0) {
                    sessionStorage.setItem('lastImageOrders', JSON.stringify({
                        ids: submittedImageIds,
                        orders: submittedImageOrders,
                        pairs: pairing,
                        timestamp: new Date().toISOString()
                    }));
                }
                
                console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                
                // Check if variants are enabled
                const hasVariantsCheckbox = document.getElementById('has_variants');
                const variantsEnabled = hasVariantsCheckbox && hasVariantsCheckbox.checked;
                
                console.log('ğŸ” PREP: Variants enabled:', variantsEnabled);
                
                if (variantsEnabled) {
                    // Get selected variant attributes
                    const selectedVariantAttributes = getSelectedVariantAttributes();
                    const selectedVariantKeys = selectedVariantAttributes.map(attr => attr.key);
                    
                    console.log('ğŸ” PREP: Selected variant attributes:', selectedVariantAttributes);
                    console.log('ğŸ” PREP: Selected variant keys:', selectedVariantKeys);
                    
                    if (selectedVariantKeys.length > 0) {
                        // Remove any existing variant_attributes input
                        const existingInput = form.querySelector('input[name="variant_attributes"]');
                        if (existingInput) {
                            existingInput.remove();
                            console.log('ğŸ”§ PREP: Removed existing variant_attributes input');
                        }
                        
                        // Create new hidden input for variant attributes
                        const variantAttrsInput = document.createElement('input');
                        variantAttrsInput.type = 'hidden';
                        variantAttrsInput.name = 'variant_attributes';
                        variantAttrsInput.value = JSON.stringify(selectedVariantKeys);
                        form.appendChild(variantAttrsInput);
                        
                        console.log('âœ… PREP: Added variant_attributes input with value:', variantAttrsInput.value);
                        
                        // Verify it was added
                        const verifyInput = form.querySelector('input[name="variant_attributes"]');
                        console.log('âœ… PREP: Verification - input found:', !!verifyInput);
                        console.log('âœ… PREP: Verification - input value:', verifyInput ? verifyInput.value : 'NOT FOUND');
                        
                        // âœ¨ Add distinctive attribute key
                        const distinctiveRadio = document.querySelector('.distinctive-radio:checked');
                        if (distinctiveRadio) {
                            const distinctiveKey = distinctiveRadio.value;
                            console.log('ğŸ¯ PREP: Distinctive attribute:', distinctiveKey);
                            
                            // Remove any existing distinctive_attribute input
                            const existingDistinctive = form.querySelector('input[name="distinctive_attribute"]');
                            if (existingDistinctive) {
                                existingDistinctive.remove();
                            }
                            
                            // Create new hidden input for distinctive attribute
                            const distinctiveInput = document.createElement('input');
                            distinctiveInput.type = 'hidden';
                            distinctiveInput.name = 'distinctive_attribute';
                            distinctiveInput.value = distinctiveKey;
                            form.appendChild(distinctiveInput);
                            
                            console.log('âœ… PREP: Added distinctive_attribute input with value:', distinctiveKey);
                        } else {
                            console.log('âš ï¸ PREP: No distinctive attribute selected');
                        }
                    } else {
                        console.log('âš ï¸ PREP: No variant attributes selected');
                    }
                } else {
                    console.log('âš ï¸ PREP: Variants not enabled');
                }
                
                console.log('âœ… PREP: Form preparation complete, allowing submission');
                return true; // Allow form submission
                
            } catch (error) {
                console.error('âŒ PREP: Error in prepareFormSubmission:', error);
                return true; // Still allow submission even if there's an error
            }
        }
        
        // Show success notification when page loads with success messages
        document.addEventListener('DOMContentLoaded', function() {
            const successMessages = document.querySelectorAll('.alert-success');
            if (successMessages.length > 0) {
                // Show notification using the existing showNotification function
                if (typeof showNotification === 'function') {
                    showNotification('Ù…Ø­ØµÙˆÙ„ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯ âœ…', 'success');
                } else {
                    // Fallback notification
                    const notification = document.getElementById('save-notification');
                    if (notification) {
                        notification.style.display = 'block';
                        setTimeout(() => {
                            notification.style.display = 'none';
                        }, 3000);
                    }
                }
            }
            
            // DEBUG: Check variant status on page load
            console.log('ğŸ” DEBUG: Page loaded, checking variant status...');
            const hasVariantsCheckbox = document.getElementById('has_variants');
            console.log('ğŸ” DEBUG: has_variants checkbox found:', !!hasVariantsCheckbox);
            if (hasVariantsCheckbox) {
                console.log('ğŸ” DEBUG: has_variants checked:', hasVariantsCheckbox.checked);
                console.log('ğŸ” DEBUG: has_variants value:', hasVariantsCheckbox.value);
            }
            
            // Check if getSelectedVariantAttributes function exists
            if (typeof getSelectedVariantAttributes === 'function') {
                const selectedAttrs = getSelectedVariantAttributes();
                console.log('ğŸ” DEBUG: Selected variant attributes on load:', selectedAttrs);
            } else {
                console.log('ğŸ” DEBUG: getSelectedVariantAttributes function not found');
            }
        });
    </script>

    <!-- Crop Modal -->
    <div class="crop-modal" id="cropModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 15000;">
        <div class="crop-modal-content" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: var(--surface-color, #2d3748); border-radius: 12px; padding: 20px; min-width: 600px; max-width: 90vw; max-height: 90vh; box-shadow: 0 20px 40px rgba(0,0,0,0.5); border: 1px solid var(--border-color, #4a5568);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid var(--border-color, #4a5568); padding-bottom: 10px;">
                <h3 style="margin: 0; color: var(--text-color, #e2e8f0);">Ø¨Ø±Ø´ ØªØµÙˆÛŒØ±</h3>
                <button type="button" onclick="closeCropModal()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: var(--text-color, #e2e8f0);">&times;</button>
            </div>
            <div class="crop-container" style="margin-bottom: 20px;">
                <img id="cropImage" src="" alt="Image to crop" style="max-width: 100%; max-height: 60vh; display: block;">
            </div>
            <div class="crop-controls" style="display: flex; gap: 10px; justify-content: flex-end;">
                <button class="crop-cancel-btn" onclick="closeCropModal()" style="padding: 10px 20px; border: 1px solid var(--border-color, #4a5568); background: var(--button-secondary-bg, #2d3748); color: var(--text-color, #e2e8f0); border-radius: 6px; cursor: pointer;">Ø§Ù†ØµØ±Ø§Ù</button>
                <button class="crop-save-btn" onclick="saveCroppedImage()" style="padding: 10px 20px; background: var(--primary-color, #3182ce); color: white; border: none; border-radius: 6px; cursor: pointer;">Ø°Ø®ÛŒØ±Ù‡</button>
            </div>
        </div>
    </div>

    <!-- Backup Variant Modal (in case include fails) -->
    <div id="backupVariantModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: var(--surface-color, #2d3748); color: var(--text-color, #e2e8f0); padding: 20px; border-radius: 12px; min-width: 500px; max-width: 700px; box-shadow: 0 20px 40px rgba(0,0,0,0.5); border: 1px solid var(--border-color, #4a5568);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid var(--border-color, #4a5568); padding-bottom: 10px;">
                <h3 id="backupVariantModalTitle" style="margin: 0; color: var(--text-color, #e2e8f0);">Ø§ÙØ²ÙˆØ¯Ù† Ù†ÙˆØ¹ Ù…Ø­ØµÙˆÙ„ Ø¬Ø¯ÛŒØ¯</h3>
                <button type="button" onclick="document.getElementById('backupVariantModal').style.display='none';" style="background: none; border: none; font-size: 24px; cursor: pointer; color: var(--text-color, #e2e8f0);">&times;</button>
            </div>
            <form id="backupVariantForm">
                {% csrf_token %}
                <input type="hidden" id="backupVariantIndex" value="">
                
                <div style="margin-bottom: 15px;">
                    <label for="backupVariantSku" style="display: block; margin-bottom: 5px; color: var(--text-color, #e2e8f0); font-weight: 500;">Ú©Ø¯ Ù…Ø­ØµÙˆÙ„ (SKU)</label>
                    <input type="text" id="backupVariantSku" style="width: 100%; padding: 10px; border: 1px solid var(--border-color, #4a5568); border-radius: 6px; background: var(--input-bg, #1a202c); color: var(--text-color, #e2e8f0);" required>
                </div>
                
                <!-- Selected Variant Attributes Section -->
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; color: var(--text-color, #e2e8f0); font-weight: 500;">ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ø´Ø¯Ù‡</label>
                    <div id="backupVariantAttributesForm" style="border: 1px solid var(--border-color, #4a5568); border-radius: 6px; padding: 15px; background: var(--input-bg, #1a202c); min-height: 80px;">
                        <p style="color: var(--text-secondary, #a0aec0); text-align: center; margin: 0; padding: 10px;">
                            Ø§Ø¨ØªØ¯Ø§ ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ù…ØªØºÛŒØ± Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯
                        </p>
                    </div>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                    <div>
                        <label for="backupVariantPrice" style="display: block; margin-bottom: 5px; color: var(--text-color, #e2e8f0); font-weight: 500;">Ù‚ÛŒÙ…Øª (ØªÙˆÙ…Ø§Ù†)</label>
                        <input type="text" id="backupVariantPrice" style="width: 100%; padding: 10px; border: 1px solid var(--border-color, #4a5568); border-radius: 6px; background: var(--input-bg, #1a202c); color: var(--text-color, #e2e8f0);" placeholder="Ø®Ø§Ù„ÛŒ Ø¨Ú¯Ø°Ø§Ø±ÛŒØ¯ ØªØ§ Ø§Ø² Ù‚ÛŒÙ…Øª Ø§ØµÙ„ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø´ÙˆØ¯">
                    </div>
                    <div>
                        <label for="backupVariantStock" style="display: block; margin-bottom: 5px; color: var(--text-color, #e2e8f0); font-weight: 500;">Ù…ÙˆØ¬ÙˆØ¯ÛŒ</label>
                        <input type="number" id="backupVariantStock" style="width: 100%; padding: 10px; border: 1px solid var(--border-color, #4a5568); border-radius: 6px; background: var(--input-bg, #1a202c); color: var(--text-color, #e2e8f0);" min="0" required>
                    </div>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <label style="display: flex; align-items: center; gap: 8px; color: var(--text-color, #e2e8f0);">
                        <input type="checkbox" id="backupVariantIsActive" checked style="margin: 0;">
                        ÙØ¹Ø§Ù„
                    </label>
                </div>
            </form>
            <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px; border-top: 1px solid var(--border-color, #4a5568); padding-top: 15px;">
                <button type="button" onclick="document.getElementById('backupVariantModal').style.display='none';" style="padding: 10px 20px; border: 1px solid var(--border-color, #4a5568); background: var(--button-secondary-bg, #2d3748); color: var(--text-color, #e2e8f0); border-radius: 6px; cursor: pointer;">Ø§Ù†ØµØ±Ø§Ù</button>
                <button type="button" onclick="saveBackupVariant()" style="padding: 10px 20px; background: var(--primary-color, #3182ce); color: white; border: none; border-radius: 6px; cursor: pointer;">Ø°Ø®ÛŒØ±Ù‡ Ù…Ø­ØµÙˆÙ„</button>
            </div>
        </div>
    </div>

    <!-- Load JavaScript Services -->
    <script src="{% static 'suppliers/templates/suppliers/add_product/utils/formUtils.js' %}"></script>
    <script src="{% static 'suppliers/templates/suppliers/add_product/validation/productValidation.js' %}"></script>
    <script src="{% static 'suppliers/templates/suppliers/add_product/services/productFormService.js' %}"></script>
    
    <!-- Initialize Form -->
    <script>
        // MAGNIFICENT VERSION - With drag-and-drop and variant functionality restored!
        console.log('ğŸš€ Magnificent version restored!');
        
        // âœ¨ CRITICAL FIX: Initialize global variables from JSON data
        // Read the JSON script tags and assign to window variables
        console.log('ğŸ” DEBUG: Starting to load category attributes...');
        try {
            const categoryAttributesData = document.getElementById('category-attributes-data');
            console.log('ğŸ” DEBUG: categoryAttributesData element:', categoryAttributesData);
            console.log('ğŸ” DEBUG: categoryAttributesData exists:', !!categoryAttributesData);
            
            if (categoryAttributesData) {
                console.log('ğŸ” DEBUG: Raw textContent:', categoryAttributesData.textContent);
                console.log('ğŸ” DEBUG: textContent length:', categoryAttributesData.textContent.length);
                
                window.categoryAttributes = JSON.parse(categoryAttributesData.textContent);
                console.log('âœ… Loaded category attributes:', window.categoryAttributes);
                console.log('âœ… Category attributes type:', typeof window.categoryAttributes);
                console.log('âœ… Category attributes keys:', Object.keys(window.categoryAttributes));
                console.log('âœ… Number of categories with attributes:', Object.keys(window.categoryAttributes).length);
                
                // Log details for each category
                Object.keys(window.categoryAttributes).forEach(catId => {
                    console.log(`âœ… Category ${catId} has ${window.categoryAttributes[catId].length} attributes`);
                });
            } else {
                console.error('âŒ category-attributes-data script tag not found!');
                console.error('âŒ All script tags on page:', document.querySelectorAll('script[type="application/json"]'));
                window.categoryAttributes = {};
            }
        } catch (e) {
            console.error('âŒ Error parsing category attributes:', e);
            console.error('âŒ Error stack:', e.stack);
            window.categoryAttributes = {};
        }
        
        try {
            const existingAttrsData = document.getElementById('existing-attrs-data');
            if (existingAttrsData) {
                window.existingAttrs = JSON.parse(existingAttrsData.textContent);
                console.log('âœ… Loaded existing attributes:', window.existingAttrs);
            } else {
                window.existingAttrs = {};
            }
        } catch (e) {
            console.error('âŒ Error parsing existing attributes:', e);
            window.existingAttrs = {};
        }
        
        try {
            const existingVariantsData = document.getElementById('existing-variants-data');
            if (existingVariantsData) {
                window.existingVariants = JSON.parse(existingVariantsData.textContent);
                console.log('âœ… Loaded existing variants:', window.existingVariants);
            } else {
                window.existingVariants = [];
            }
        } catch (e) {
            console.error('âŒ Error parsing existing variants:', e);
            window.existingVariants = [];
        }
        
        try {
            const productImagesData = document.getElementById('product-images-data');
            if (productImagesData) {
                window.productImages = JSON.parse(productImagesData.textContent);
                console.log('âœ… Loaded product images:', window.productImages);
            } else {
                window.productImages = [];
            }
        } catch (e) {
            console.error('âŒ Error parsing product images:', e);
            window.productImages = [];
        }
        
        document.addEventListener('DOMContentLoaded', function() {
            console.log('ğŸš€ DOMContentLoaded fired');
            
            const imageInput = document.getElementById('imageInput');
            const mainContainer = document.getElementById('imagePreviews');
            const variantModal = document.getElementById('variantModal');
            let currentContainer = mainContainer;
            
            // Make slider clickable
            makeSliderClickable();
            
            // MAGNIFICENT DRAG-AND-DROP FUNCTIONALITY RESTORED!
            let draggedElement = null;
            let draggedIndex = null;

            // Helper: ensure the correct input is clickable even if main input is disabled
            window.triggerVariantFileDialog = function() {
                const mainInput = document.getElementById('imageInput');
                if (!mainInput) {
                    console.warn('No main image input found to trigger');
                    return;
                }

                const wasDisabled = mainInput.disabled;
                if (wasDisabled) {
                    // Re-disable only AFTER the user selects files
                    const restoreAfterChange = function() {
                        mainInput.removeEventListener('change', restoreAfterChange);
                        mainInput.disabled = true;
                    };
                    mainInput.addEventListener('change', restoreAfterChange);
                    mainInput.disabled = false;
                }
                mainInput.click();
            };

            // âœ¨ CRITICAL: Ensure image input is enabled by default if variants are not enabled
            const variantsCheckbox = document.querySelector('input[name="has_variants"]');
            if (variantsCheckbox && !variantsCheckbox.checked) {
                if (imageInput) {
                    imageInput.disabled = false;
                    console.log('âœ… Image input enabled (variants checkbox unchecked)');
                }
            } else if (!variantsCheckbox) {
                // If checkbox doesn't exist, ensure input is enabled
                if (imageInput) {
                    imageInput.disabled = false;
                    console.log('âœ… Image input enabled (no variants checkbox found)');
                }
            } else {
                console.log('â„¹ï¸ Image input disabled (variants enabled)');
            }
            
            // Always ensure the main input is enabled before form submit so files are sent
            const productForm = document.getElementById('product_form');
            if (productForm) {
                productForm.addEventListener('submit', function() {
                    const mainInput = document.getElementById('imageInput');
                    if (mainInput) mainInput.disabled = false;
                });
            }
            
            function initializeDragAndDrop() {
                if (!currentContainer) {
                    console.log('âŒ Container not found');
                    return;
                }

                // Add drag and drop event listeners to current container
                currentContainer.addEventListener('dragover', handleDragOver);
                currentContainer.addEventListener('drop', handleDrop);
                currentContainer.addEventListener('dragenter', handleDragEnter);
                currentContainer.addEventListener('dragleave', handleDragLeave);

                console.log('âœ… Magnificent drag-and-drop initialized!');
            }

            // Function to switch container for variant modal
            function switchContainerToVariant() {
                if (variantModal) {
                    const variantContainer = variantModal.querySelector('#variantImagePreviews');
                    if (variantContainer) {
                        currentContainer = variantContainer;
                        console.log('âœ… Switched to variant container');
                    }
                }
            }

            // Set up variant image input handler
            const variantImageInput = document.getElementById('variantImageInput');
            console.log('ğŸ” Setting up variant image input handler, input found:', !!variantImageInput);
            
            if (variantImageInput) {
                console.log('âœ… Adding change event listener to variant image input');
                variantImageInput.addEventListener('change', function(e) {
                    console.log('ğŸ“· Variant files selected:', e.target.files.length);
                    console.log('ğŸ“· Variant input disabled state:', e.target.disabled);
                    
                    const files = Array.from(e.target.files);
                    const targetContainer = document.getElementById('variantImagePreviews');
                    
                    if (!targetContainer) {
                        console.error('âŒ Variant image preview container not found!');
                        return;
                    }

                    files.forEach((file, index) => {
                        if (file.type.startsWith('image/')) {
                            const reader = new FileReader();
                            reader.onload = function(e) {
                                const previewDiv = document.createElement('div');
                                previewDiv.className = 'preview-item';
                                previewDiv.style.cssText = `
                                    display: flex;
                                    flex-direction: column;
                                    position: relative;
                                    border-radius: 8px;
                                    overflow: hidden;
                                    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                                    cursor: move;
                                    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                                    user-select: none;
                                `;

                                const img = document.createElement('img');
                                img.src = e.target.result;
                                img.style.cssText = `
                                    display: block;
                                    width: 150px;
                                    height: 150px;
                                    object-fit: cover;
                                    pointer-events: none;
                                `;

                                // Order label
                                const label = document.createElement('div');
                                label.className = 'position-label';
                                label.style.cssText = `
                                    position: absolute;
                                    top: 5px;
                                    left: 5px;
                                    background: rgba(0,0,0,0.9);
                                    color: white;
                                    padding: 2px 6px;
                                    border-radius: 3px;
                                    font-size: 12px;
                                    font-weight: bold;
                                    z-index: 10;
                                    pointer-events: none;
                                `;
                                label.textContent = `${targetContainer.children.length + 1}/${files.length}`;

                                // Crop button
                                const cropBtn = document.createElement('button');
                                cropBtn.type = 'button';
                                cropBtn.innerHTML = 'âœ‚ï¸';
                                cropBtn.title = 'Ø¨Ø±Ø´ ØªØµÙˆÛŒØ±';
                                cropBtn.style.cssText = `
                                    position: absolute;
                                    top: 5px;
                                    right: 35px;
                                    background: rgba(49, 130, 206, 0.9);
                                    color: white;
                                    border: none;
                                    border-radius: 50%;
                                    width: 25px;
                                    height: 25px;
                                    cursor: pointer;
                                    font-size: 12px;
                                    z-index: 10;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                `;
                                cropBtn.onclick = function(e) {
                                    e.preventDefault();
                                    e.stopPropagation();
                                    openCropModal(img.src, previewDiv);
                                };

                                // Remove button
                                const deleteBtn = document.createElement('button');
                                deleteBtn.type = 'button';
                                deleteBtn.innerHTML = 'Ã—';
                                deleteBtn.title = 'Ø­Ø°Ù ØªØµÙˆÛŒØ±';
                                deleteBtn.style.cssText = `
                                    position: absolute;
                                    top: 5px;
                                    right: 5px;
                                    background: rgba(255,0,0,0.9);
                                    color: white;
                                    border: none;
                                    border-radius: 50%;
                                    width: 25px;
                                    height: 25px;
                                    cursor: pointer;
                                    font-size: 16px;
                                    z-index: 10;
                                `;
                                deleteBtn.onclick = function(e) {
                                    e.preventDefault();
                                    e.stopPropagation();
                                    previewDiv.remove();
                                    updateVariantImagePositions();
                                };

                                previewDiv.appendChild(img);
                                previewDiv.appendChild(label);
                                previewDiv.appendChild(cropBtn);
                                previewDiv.appendChild(deleteBtn);
                                targetContainer.appendChild(previewDiv);

                                // Make the preview item draggable
                                makeElementDraggable(previewDiv, targetContainer.children.length - 1);

                                // Initialize drag and drop for variant container if this is the first image
                                if (targetContainer.children.length === 1) {
                                    initializeDragAndDropForVariant(targetContainer);
                                }

                                console.log('âœ… Variant image preview added');
                            };
                            reader.readAsDataURL(file);
                        }
                    });
                });
            }
            
            function handleDragOver(e) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                
                // Add hover effect to potential drop targets
                const dropTarget = e.target.closest('.preview-item');
                if (dropTarget && dropTarget !== draggedElement) {
                    // Remove hover from all other items
                    currentContainer.querySelectorAll('.preview-item').forEach(item => {
                        if (item !== draggedElement) {
                            item.classList.remove('drop-target');
                        }
                    });
                    // Add hover to current target
                    dropTarget.classList.add('drop-target');
                }
            }
            
            function handleDragEnter(e) {
                e.preventDefault();
                currentContainer.classList.add('drag-over');
            }

            function handleDragLeave(e) {
                if (!currentContainer.contains(e.relatedTarget)) {
                    currentContainer.classList.remove('drag-over');
                    // Remove all drop target hovers when leaving container
                    currentContainer.querySelectorAll('.preview-item').forEach(item => {
                        item.classList.remove('drop-target');
                    });
                }
            }
            
            function handleDrop(e) {
                e.preventDefault();
                
                // Determine which container this drop is happening in
                const dropContainer = e.currentTarget;
                dropContainer.classList.remove('drag-over');

                // Remove all drop target hovers
                dropContainer.querySelectorAll('.preview-item').forEach(item => {
                    item.classList.remove('drop-target');
                });

                if (!draggedElement) {
                    console.log('âš ï¸ No dragged element');
                    return;
                }

                const dropTarget = e.target.closest('.preview-item');
                if (!dropTarget || dropTarget === draggedElement) {
                    console.log('âš ï¸ Invalid drop target');
                    draggedElement.classList.remove('dragging');
                    draggedElement = null;
                    draggedIndex = null;
                    return;
                }

                // Get current indices from actual DOM position (not stored indices)
                const currentChildren = Array.from(dropContainer.children).filter(child => 
                    child.classList.contains('preview-item')
                );
                const currentDragIndex = currentChildren.indexOf(draggedElement);
                const currentDropIndex = currentChildren.indexOf(dropTarget);
                
                const draggedId = draggedElement.getAttribute('data-image-id') || 'NEW';
                const targetId = dropTarget.getAttribute('data-image-id') || 'NEW';

                console.log(`ğŸ”„ DROP: Moving item ID ${draggedId} from DOM position ${currentDragIndex + 1} to position ${currentDropIndex + 1}`);
                console.log(`   Drop target is item ID ${targetId} at position ${currentDropIndex + 1}`);

                // Store old order for comparison
                const oldOrder = currentChildren.map((child, idx) => {
                    const id = child.getAttribute('data-image-id') || `NEW-${idx}`;
                    return `${id}:${idx + 1}`;
                }).join(', ');
                console.log(`   Old order: ${oldOrder}`);

                // Move the element using current DOM positions
                if (currentDragIndex < currentDropIndex) {
                    // Moving down - insert after the target
                    if (dropTarget.nextSibling) {
                        dropContainer.insertBefore(draggedElement, dropTarget.nextSibling);
                    } else {
                        dropContainer.appendChild(draggedElement);
                    }
                } else if (currentDragIndex > currentDropIndex) {
                    // Moving up - insert before the target
                    dropContainer.insertBefore(draggedElement, dropTarget);
                } else {
                    // Same position - no change needed
                    console.log('   Same position, no move needed');
                }

                // Force DOM update
                dropContainer.offsetHeight; // Trigger reflow

                // Verify new order
                const newChildren = Array.from(dropContainer.children).filter(child => 
                    child.classList.contains('preview-item')
                );
                const newOrder = newChildren.map((child, idx) => {
                    const id = child.getAttribute('data-image-id') || `NEW-${idx}`;
                    return `${id}:${idx + 1}`;
                }).join(', ');
                console.log(`   New order: ${newOrder}`);
                console.log(`   âœ… DOM reordered successfully`);

                // Update positions based on which container
                if (dropContainer.id === 'variantImagePreviews') {
                    updateVariantImagePositions();
                } else {
                    updateImagePositions();
                }
                
                // âœ¨ PROMINENT LOG AFTER SWIPING
                console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                console.log('ğŸ“¸ IMAGE ORDER AFTER SWIPING:');
                console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                newChildren.forEach((child, idx) => {
                    const id = child.getAttribute('data-image-id') || 'NEW';
                    const label = child.querySelector('.position-label');
                    const labelText = label ? label.textContent : '?';
                    console.log(`  Position ${idx + 1}: Image ID ${id} (Label: ${labelText})`);
                });
                console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                console.log(`âœ… Order saved to DOM. When you save the product, these orders will be submitted.`);
                console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');

                // Clean up
                draggedElement.classList.remove('dragging');
                draggedElement = null;
                draggedIndex = null;
            }
            
            function makeElementDraggable(element, index) {
                // Only add listeners if not already draggable (avoid duplicates)
                if (element.draggable) return;
                
                element.draggable = true;
                element.classList.add('draggable');
                
                element.addEventListener('dragstart', function(e) {
                    // Get current index from DOM position at drag time (always fresh)
                    const container = this.parentNode;
                    const currentChildren = Array.from(container.children).filter(child => 
                        child.classList.contains('preview-item')
                    );
                    const currentIndex = currentChildren.indexOf(this);
                    
                    draggedElement = this;
                    draggedIndex = currentIndex; // Store current DOM position
                    this.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/html', this.outerHTML);
                    console.log(`ğŸš€ Started dragging item at current DOM position ${currentIndex}`);
                });
                
                element.addEventListener('dragend', function(e) {
                    this.classList.remove('dragging');
                    console.log('ğŸ Drag ended');
                });
            }
            
            // Function to initialize drag and drop for variant container
            function initializeDragAndDropForVariant(container) {
                if (!container) {
                    console.log('âŒ Variant container not found');
                    return;
                }

                console.log('âœ… Initializing drag and drop for variant container');

                // Add drag and drop event listeners to variant container
                container.addEventListener('dragover', handleDragOver);
                container.addEventListener('drop', handleDrop);
                container.addEventListener('dragenter', handleDragEnter);
                container.addEventListener('dragleave', handleDragLeave);

                console.log('âœ… Variant drag and drop initialized!');
            }

            // Function to update image positions for main container
            function updateImagePositions() {
                const mainContainer = document.getElementById('imagePreviews');
                if (!mainContainer) return;
                
                const images = mainContainer.querySelectorAll('.preview-item');
                images.forEach((item, index) => {
                    const label = item.querySelector('.position-label');
                    if (label) {
                        label.textContent = `${index + 1}/${images.length}`;
                    }
                });
            }
            
            // Function to update image positions for variant container
            function updateVariantImagePositions() {
                const variantContainer = document.getElementById('variantImagePreviews');
                if (!variantContainer) return;
                
                const images = variantContainer.querySelectorAll('.preview-item');
                images.forEach((item, index) => {
                    const label = item.querySelector('.position-label');
                    if (label) {
                        label.textContent = `${index + 1}/${images.length}`;
                    }
                });
            }
            if (imageInput) {
                imageInput.addEventListener('change', function(e) {
                    console.log('ğŸ“· ===== FILE INPUT CHANGE EVENT =====');
                    console.log('ğŸ“· Files selected:', e.target.files.length);
                    console.log('ğŸ“· Current container:', currentContainer ? currentContainer.id : 'none');
                    console.log('ğŸ“· Image input disabled?', imageInput.disabled);

                    if (imageInput.disabled) {
                        console.error('âŒ Image input is DISABLED! Cannot add images.');
                        console.log('ğŸ’¡ Tip: Make sure variants are disabled if you want to add main product images.');
                        return;
                    }

                    const files = Array.from(e.target.files);
                    const targetContainer = currentContainer || document.getElementById('imagePreviews');
                    
                    if (!targetContainer) {
                        console.error('âŒ Target container not found!');
                        return;
                    }
                    
                    console.log(`ğŸ“¦ Adding ${files.length} new image(s) to container (currently has ${targetContainer.children.length} images)`);
                    
                    let newImageCount = 0;
                    files.forEach((file, index) => {
                        if (file.type.startsWith('image/')) {
                            newImageCount++;
                            const reader = new FileReader();
                            reader.onload = function(e) {
                                const previewDiv = document.createElement('div');
                                previewDiv.className = 'preview-item';
                                // âœ¨ CRITICAL: New images should NOT have data-image-id attribute
                                // This ensures collectImageData knows it's a new image, not existing
                                // (Existing images have data-image-id set to their database ID)
                                previewDiv.style.cssText = `
                                    display: flex;
                                    flex-direction: column;
                                    position: relative;
                                    border-radius: 8px;
                                    overflow: hidden;
                                    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                                    cursor: move;
                                    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                                    user-select: none;
                                `;
                                
                                // Add hover effect
                                previewDiv.addEventListener('mouseenter', function() {
                                    this.style.transform = 'scale(1.05)';
                                });
                                previewDiv.addEventListener('mouseleave', function() {
                                    this.style.transform = 'scale(1)';
                                });
                                
                                const img = document.createElement('img');
                                img.src = e.target.result;
                                img.style.cssText = `
                                    display: block;
                                    width: 150px;
                                    height: 150px;
                                    object-fit: cover;
                                    pointer-events: none;
                                `;
                                
                                // Order label - calculate AFTER adding to container
                                const label = document.createElement('div');
                                label.className = 'position-label';
                                label.style.cssText = `
                                    position: absolute;
                                    top: 5px;
                                    left: 5px;
                                    background: rgba(0,0,0,0.9);
                                    color: white;
                                    padding: 2px 6px;
                                    border-radius: 3px;
                                    font-size: 12px;
                                    font-weight: bold;
                                    z-index: 10;
                                    pointer-events: none;
                                `;
                                
                                // Crop button
                                const cropBtn = document.createElement('button');
                                cropBtn.type = 'button';
                                cropBtn.innerHTML = 'âœ‚ï¸';
                                cropBtn.title = 'Ø¨Ø±Ø´ ØªØµÙˆÛŒØ±';
                                cropBtn.style.cssText = `
                                    position: absolute;
                                    top: 5px;
                                    right: 35px;
                                    background: rgba(49, 130, 206, 0.9);
                                    color: white;
                                    border: none;
                                    border-radius: 50%;
                                    width: 25px;
                                    height: 25px;
                                    cursor: pointer;
                                    font-size: 12px;
                                    z-index: 10;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                `;
                                cropBtn.onclick = function(e) {
                                    e.preventDefault();
                                    e.stopPropagation();
                                    openCropModal(img.src, previewDiv);
                                };

                                // Delete button
                                const deleteBtn = document.createElement('button');
                                deleteBtn.type = 'button';
                                deleteBtn.innerHTML = 'Ã—';
                                deleteBtn.style.cssText = `
                                    position: absolute;
                                    top: 5px;
                                    right: 5px;
                                    background: rgba(255,0,0,0.9);
                                    color: white;
                                    border: none;
                                    border-radius: 50%;
                                    width: 25px;
                                    height: 25px;
                                    cursor: pointer;
                                    font-size: 16px;
                                    z-index: 10;
                                `;
                                deleteBtn.onclick = function(e) {
                                    e.preventDefault();
                                    e.stopPropagation();
                                    console.log('ğŸ—‘ï¸ Deleting new image from preview');
                                    previewDiv.remove();
                                    updateImagePositions();
                                    // Also clear the file input if all new images are removed
                                    // New images don't have data-image-id attribute, or it's empty/null
                                    const remainingNewImages = Array.from(targetContainer.children).filter(item => {
                                        const id = item.getAttribute('data-image-id');
                                        return !id || id === 'undefined' || id === 'null' || id === '';
                                    });
                                    if (remainingNewImages.length === 0) {
                                        imageInput.value = ''; // Clear file input
                                        console.log('ğŸ§¹ Cleared file input (no new images remaining)');
                                    }
                                };
                                
                                previewDiv.appendChild(img);
                                previewDiv.appendChild(label);
                                previewDiv.appendChild(cropBtn);
                                previewDiv.appendChild(deleteBtn);
                                targetContainer.appendChild(previewDiv);
                                
                                console.log(`âœ… Added new image ${newImageCount} to preview (total: ${targetContainer.children.length})`);

                                // Make the new element draggable
                                const currentIndex = targetContainer.children.length - 1;
                                makeElementDraggable(previewDiv, currentIndex);

                                // Initialize drag and drop after first image is added
                                if (targetContainer.children.length === 1) {
                                    initializeDragAndDrop();
                                }

                                // Update positions after adding (this will fix the label)
                                updateImagePositions();
                                
                                console.log(`âœ… New image added successfully. Container now has ${targetContainer.children.length} images`);
                            };
                            reader.onerror = function(e) {
                                console.error('âŒ Error reading file:', file.name, e);
                            };
                            reader.readAsDataURL(file);
                        } else {
                            console.warn(`âš ï¸ Skipped non-image file: ${file.name} (type: ${file.type})`);
                        }
                    });
                    
                    console.log(`ğŸ“· Processed ${newImageCount} image(s) from ${files.length} file(s)`);
                    console.log('ğŸ“· ===== FILE INPUT CHANGE EVENT END =====');
                });
                
                console.log('âœ… Image input event listener attached');
            } else {
                console.error('âŒ Image input element not found!');
            }
            
            // Initialize drag and drop immediately if container exists
            initializeDragAndDrop();
            
            // âœ¨ CRITICAL: Load existing product images into preview container
            function loadExistingProductImages() {
                const mainContainer = document.getElementById('imagePreviews');
                if (!mainContainer || !window.productImages || window.productImages.length === 0) {
                    console.log('â„¹ï¸ No existing product images to load');
                    return;
                }
                
                console.log(`ğŸ–¼ï¸ Loading ${window.productImages.length} existing product images...`);
                
                // Log the order they're being loaded in
                console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                console.log('ğŸ“¸ IMAGES BEING LOADED FROM BACKEND:');
                console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                window.productImages.forEach((imageData, idx) => {
                    console.log(`  Position ${idx + 1}: Image ID ${imageData.id}, Order ${imageData.order}, URL: ${imageData.url.substring(0, 50)}...`);
                });
                console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                
                // Check if we have stored orders from last submission
                const lastOrders = sessionStorage.getItem('lastImageOrders');
                if (lastOrders) {
                    try {
                        const lastOrdersData = JSON.parse(lastOrders);
                        console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                        console.log('ğŸ” CHECKING: Orders sent in last submission vs current DB order:');
                        console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                        console.log('Last submission (what we sent):');
                        lastOrdersData.pairs.forEach(pair => console.log(`  ${pair}`));
                        console.log('Current DB order (what we loaded):');
                        window.productImages.forEach((img, idx) => {
                            console.log(`  Position ${idx + 1}: Image ID ${img.id}, Order ${img.order}`);
                        });
                        
                        // Check for mismatches
                        const dbOrders = {};
                        window.productImages.forEach(img => {
                            dbOrders[img.id] = img.order;
                        });
                        
                        let mismatch = false;
                        lastOrdersData.ids.forEach((id, idx) => {
                            const expectedOrder = parseInt(lastOrdersData.orders[idx]);
                            const actualOrder = dbOrders[id];
                            if (actualOrder !== expectedOrder) {
                                console.error(`  âŒ MISMATCH: Image ${id} should be order ${expectedOrder} but is ${actualOrder}`);
                                mismatch = true;
                            }
                        });
                        
                        if (!mismatch) {
                            console.log('âœ… Orders match! Database has correct order.');
                        } else {
                            console.error('âŒ ORDERS DON\'T MATCH! Database order is different from what we sent.');
                        }
                        console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                    } catch (e) {
                        console.error('Error checking last orders:', e);
                    }
                }
                
                window.productImages.forEach((imageData, index) => {
                    const previewDiv = document.createElement('div');
                    previewDiv.className = 'preview-item';
                    previewDiv.setAttribute('data-image-id', imageData.id);
                    previewDiv.style.cssText = `
                        display: flex;
                        flex-direction: column;
                        position: relative;
                        border-radius: 8px;
                        overflow: hidden;
                        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                        cursor: move;
                        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                        user-select: none;
                    `;
                    
                    // Add hover effect
                    previewDiv.addEventListener('mouseenter', function() {
                        this.style.transform = 'scale(1.05)';
                    });
                    previewDiv.addEventListener('mouseleave', function() {
                        this.style.transform = 'scale(1)';
                    });
                    
                    const img = document.createElement('img');
                    img.src = imageData.url;
                    img.style.cssText = `
                        display: block;
                        width: 150px;
                        height: 150px;
                        object-fit: cover;
                        pointer-events: none;
                    `;
                    
                    // Order label
                    const label = document.createElement('div');
                    label.className = 'position-label';
                    label.style.cssText = `
                        position: absolute;
                        top: 5px;
                        left: 5px;
                        background: rgba(0,0,0,0.9);
                        color: white;
                        padding: 2px 6px;
                        border-radius: 3px;
                        font-size: 12px;
                        font-weight: bold;
                        z-index: 10;
                        pointer-events: none;
                    `;
                    label.textContent = `${index + 1}/${window.productImages.length}`;
                    
                    // Crop button
                    const cropBtn = document.createElement('button');
                    cropBtn.type = 'button';
                    cropBtn.innerHTML = 'âœ‚ï¸';
                    cropBtn.title = 'Ø¨Ø±Ø´ ØªØµÙˆÛŒØ±';
                    cropBtn.style.cssText = `
                        position: absolute;
                        top: 5px;
                        right: 35px;
                        background: rgba(49, 130, 206, 0.9);
                        color: white;
                        border: none;
                        border-radius: 50%;
                        width: 25px;
                        height: 25px;
                        cursor: pointer;
                        font-size: 12px;
                        z-index: 10;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    `;
                    cropBtn.onclick = function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        openCropModal(img.src, previewDiv);
                    };
                    
                    // Delete button
                    const deleteBtn = document.createElement('button');
                    deleteBtn.type = 'button';
                    deleteBtn.innerHTML = 'Ã—';
                    deleteBtn.title = 'Ø­Ø°Ù ØªØµÙˆÛŒØ±';
                    deleteBtn.style.cssText = `
                        position: absolute;
                        top: 5px;
                        right: 5px;
                        background: rgba(255,0,0,0.9);
                        color: white;
                        border: none;
                        border-radius: 50%;
                        width: 25px;
                        height: 25px;
                        cursor: pointer;
                        font-size: 16px;
                        z-index: 10;
                    `;
                    deleteBtn.onclick = function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        previewDiv.remove();
                        updateImagePositions();
                    };
                    
                    previewDiv.appendChild(img);
                    previewDiv.appendChild(label);
                    previewDiv.appendChild(cropBtn);
                    previewDiv.appendChild(deleteBtn);
                    mainContainer.appendChild(previewDiv);
                    
                    // Make the preview item draggable
                    makeElementDraggable(previewDiv, index);
                });
                
                // Initialize drag and drop after loading existing images
                if (mainContainer.children.length > 0) {
                    initializeDragAndDrop();
                }
                
                console.log(`âœ… Loaded ${window.productImages.length} existing product images`);
                updateImagePositions();
            }
            
            // Load existing images on page load
            loadExistingProductImages();
            
            console.log('âœ… Magnificent image upload with drag-and-drop restored!');
        });
        
        // VARIANT FUNCTIONALITY RESTORED!
        let variantState = {
            isEnabled: false,
            variants: [],
            variantImages: {} // Store images per variant ID
        };
        
        // Function to collect variant data from the table
        function collectVariantDataFromTable() {
            console.log('ğŸ” Collecting variant data from table...');
            const variants = [];
            const tableBody = document.getElementById('variantsTableBody');
            
            console.log('ğŸ” Table body element:', tableBody);
            console.log('ğŸ” DEBUG: Starting variant data collection...');
            
            if (!tableBody) {
                console.log('âŒ Variants table body not found');
                // Try alternative selectors
                const altTable = document.getElementById('variantsTable');
                console.log('ğŸ” Alternative table element:', altTable);
                if (altTable) {
                    const tbody = altTable.querySelector('tbody');
                    console.log('ğŸ” Alternative tbody element:', tbody);
                }
                return variants;
            }
            
            const rows = tableBody.querySelectorAll('tr');
            console.log(`ğŸ” Found ${rows.length} variant rows`);
            
            if (rows.length === 0) {
                console.log('ğŸ” No rows found in table body');
                console.log('ğŸ” Table body innerHTML:', tableBody.innerHTML);
            }
            
            rows.forEach((row, index) => {
                console.log(`ğŸ” Processing row ${index}:`, row);
                const cells = row.querySelectorAll('td');
                console.log(`ğŸ” Row ${index} has ${cells.length} cells`);
                
                if (cells.length >= 5) {
                    const sku = cells[0].textContent.trim();
                    const attributesText = cells[1].textContent.trim();
                    const priceText = cells[2].textContent.trim();
                    const stockText = cells[3].textContent.trim();
                    const statusText = cells[4].textContent.trim();
                    
                    console.log(`ğŸ” Row ${index} data:`, {
                        sku, attributesText, priceText, stockText, statusText
                    });
                    
                    // Parse attributes from text (e.g., "Ø±Ù†Ú¯: Ù‚Ø±Ù…Ø² Ø³Ø§ÛŒØ²: M")
                    const attributes = {};
                    if (attributesText && attributesText !== '-') {
                        console.log('ğŸ” Parsing attributes text:', attributesText);
                        
                        // Try different parsing methods
                        // Method 1: Split by space and look for key:value pairs
                        const attrPairs = attributesText.split(' ');
                        attrPairs.forEach(pair => {
                            if (pair.includes(':')) {
                                const colonIndex = pair.indexOf(':');
                                const key = pair.substring(0, colonIndex).trim();
                                const value = pair.substring(colonIndex + 1).trim();
                                if (key && value) {
                                    attributes[key] = value;
                                    console.log('ğŸ” Parsed attribute:', key, '=', value);
                                }
                            }
                        });
                        
                        // Method 2: If no attributes found, try regex parsing
                        if (Object.keys(attributes).length === 0) {
                            const regex = /([^:]+):\s*([^:]+?)(?=\s+[^:]+:|$)/g;
                            let match;
                            while ((match = regex.exec(attributesText)) !== null) {
                                const key = match[1].trim();
                                const value = match[2].trim();
                                if (key && value) {
                                    attributes[key] = value;
                                    console.log('ğŸ” Regex parsed attribute:', key, '=', value);
                                }
                            }
                        }
                        
                        console.log('ğŸ” Final parsed attributes:', attributes);
                    }
                    
                    console.log(`ğŸ” DEBUG: Variant ${index} attributes after parsing:`, attributes);
                    
                    // Parse price (remove commas and ØªÙˆÙ…Ø§Ù†)
                    const price = priceText.replace(/[,\sØªÙˆÙ…Ø§Ù†]/g, '') || '0';
                    
                    // Parse stock (extract number)
                    const stock = parseInt(stockText) || 0;
                    
                    // Determine if active
                    const isActive = statusText.includes('ÙØ¹Ø§Ù„');
                    
                    // Determine if default (look for default indicator in status or attributes)
                    const isDefault = statusText.includes('Ù¾ÛŒØ´â€ŒÙØ±Ø¶') || attributesText.includes('Ù¾ÛŒØ´â€ŒÙØ±Ø¶');
                    
                    // Collect variant images (if any)
                    // Get images from stored variant images
                    const variantImages = variantState.variantImages[sku] || [];
                    console.log(`ğŸ” Variant ${index} (${sku}) has ${variantImages.length} stored images`);
                    
                    const variant = {
                        id: `variant-${index}`,
                        sku: sku,
                        attributes: attributes,
                        priceToman: price,
                        stock: stock,
                        isActive: isActive,
                        isDefault: isDefault,
                        images: variantImages
                    };
                    
                    variants.push(variant);
                    console.log(`âœ… Collected variant ${index + 1}:`, variant);
                    console.log(`ğŸ” DEBUG: Variant ${index + 1} final attributes:`, variant.attributes);
                } else {
                    console.log(`âš ï¸ Row ${index} has insufficient cells (${cells.length}), skipping`);
                }
            });
            
            console.log(`âœ… Total variants collected: ${variants.length}`);
            console.log('âœ… Final variants array:', variants);
            console.log('ğŸ” DEBUG: All variants attributes summary:');
            variants.forEach((variant, index) => {
                console.log(`ğŸ” DEBUG: Variant ${index + 1} (${variant.sku}) attributes:`, variant.attributes);
            });
            return variants;
        }
        
        // Function to add variant data to form before submission
        function addVariantDataToForm() {
            console.log('ğŸ” addVariantDataToForm called');
            
            const form = document.getElementById('product_form');
            if (!form) {
                console.log('âŒ Form not found');
                return;
            }
            
            // Remove existing variant inputs
            const existingInputs = form.querySelectorAll('input[name="variants_data"], input[name="variant_attributes"]');
            existingInputs.forEach(input => input.remove());
            
            // Check if variants are enabled
            const hasVariantsCheckbox = document.getElementById('has_variants');
            const variantsEnabled = hasVariantsCheckbox && hasVariantsCheckbox.checked;
            
            console.log('ğŸ” Variants enabled:', variantsEnabled);
            console.log('ğŸ” Has variants checkbox:', hasVariantsCheckbox);
            console.log('ğŸ” Checkbox checked:', hasVariantsCheckbox ? hasVariantsCheckbox.checked : 'N/A');
            
            if (!variantsEnabled) {
                console.log('ğŸ” Variants not enabled - skipping variant data collection');
                return;
            }
            
            // Get selected variant attributes and add them to form
            const selectedAttributes = getSelectedVariantAttributes();
            const selectedKeys = selectedAttributes.map(attr => attr.key);
            console.log('ğŸ” Selected variant attribute keys:', selectedKeys);
            
            if (selectedKeys.length > 0) {
                // Add variant_attributes input
                const variantAttrsInput = document.createElement('input');
                variantAttrsInput.type = 'hidden';
                variantAttrsInput.name = 'variant_attributes';
                variantAttrsInput.value = JSON.stringify(selectedKeys);
                form.appendChild(variantAttrsInput);
                console.log('âœ… Added variant_attributes to form:', variantAttrsInput.value);
            }
            
            // Collect variant data from table
            console.log('ğŸ” Collecting variant data from table...');
            const variants = collectVariantDataFromTable();
            
            console.log('ğŸ” Collected variants:', variants);
            console.log('ğŸ” Number of variants:', variants.length);
            console.log('ğŸ” Variants type:', typeof variants);
            
            if (variants.length === 0) {
                console.log('ğŸ” No variants found in table - checking if variants table exists');
                const variantsTable = document.getElementById('variantsTable');
                console.log('ğŸ” Variants table element:', variantsTable);
                if (variantsTable) {
                    const rows = variantsTable.querySelectorAll('tbody tr');
                    console.log('ğŸ” Number of table rows:', rows.length);
                    rows.forEach((row, index) => {
                        console.log(`ğŸ” Row ${index}:`, row.innerHTML);
                    });
                }
                return;
            }
            
            // Default image propagation by color: if any variant for a color has images,
            // apply them to other variants of the same color that lack images
            try {
                const colorToImages = {};
                variants.forEach(v => {
                    const colorVal = v && v.attributes ? (v.attributes.color || v.attributes['Ø±Ù†Ú¯']) : undefined;
                    if (colorVal && Array.isArray(v.images) && v.images.length > 0) {
                        if (!colorToImages[colorVal]) colorToImages[colorVal] = v.images;
                    }
                });
                if (Object.keys(colorToImages).length > 0) {
                    variants.forEach(v => {
                        const colorVal = v && v.attributes ? (v.attributes.color || v.attributes['×¨Ù†Ú¯'] || v.attributes['Ø± Ù†Ú¯'] || v.attributes['Ø±Ù†Ú¯']) : undefined;
                        if (colorVal && (!Array.isArray(v.images) || v.images.length === 0)) {
                            const imgs = colorToImages[colorVal];
                            if (imgs && imgs.length > 0) {
                                v.images = imgs;
                            }
                        }
                    });
                }
            } catch (_) {}

            // Add variant data to form
            const variantDataInput = document.createElement('input');
            variantDataInput.type = 'hidden';
            variantDataInput.name = 'variants_data';
            variantDataInput.value = JSON.stringify(variants);
            form.appendChild(variantDataInput);
            
            console.log('âœ… Added variants_data to form');
            console.log('âœ… Variant data JSON:', variantDataInput.value);
            console.log('âœ… Form now has variants_data input:', form.querySelector('input[name="variants_data"]'));
            
            // Also log the form data that will be submitted
            const formData = new FormData(form);
            console.log('ğŸ” Form data keys:', Array.from(formData.keys()));
            console.log('ğŸ” Variants data in FormData:', formData.get('variants_data'));
            console.log('ğŸ” Variant attributes in FormData:', formData.get('variant_attributes'));
            
            // âœ¨ CRITICAL: Log the actual variant data being sent
            const variantsData = JSON.parse(variantDataInput.value);
            console.log('ğŸ” Variants data being sent:', variantsData);
            console.log('ğŸ” Number of variants:', variantsData.length);
            variantsData.forEach((variant, index) => {
                console.log(`ğŸ” Variant ${index + 1} (${variant.sku}):`, {
                    sku: variant.sku,
                    attributes: variant.attributes,
                    images: variant.images ? variant.images.length : 0,
                    firstImagePreview: variant.images && variant.images[0] ? variant.images[0].substring(0, 100) + '...' : 'No images'
                });
            });
        }
        
        // Function to clear variant image upload area
        function clearVariantImageUpload() {
            console.log('ğŸ§¹ Clearing variant image upload area');
            console.log('ğŸ” Checking variant image input state before clearing...');
            const variantInput = document.getElementById('variantImageInput');
            console.log('ğŸ” Variant input found:', !!variantInput);
            console.log('ğŸ” Variant input disabled:', variantInput ? variantInput.disabled : 'N/A');
            const variantImageContainer = document.getElementById('variantImagePreviews');
            if (variantImageContainer) {
                variantImageContainer.innerHTML = '';
                console.log('âœ… Variant image container cleared');
            }
            
            // Also clear the file input
            const variantImageInput = document.getElementById('variantImageInput');
            if (variantImageInput) {
                variantImageInput.value = '';
                console.log('âœ… Variant image input cleared');
                console.log('ğŸ” Variant input disabled state after clearing:', variantImageInput.disabled);
            } else {
                console.error('âŒ Variant image input not found for clearing!');
            }
        }

        // Function to load existing variants into the table
        function loadExistingVariants() {
            console.log('ğŸ”„ Loading existing variants...');
            console.log('ğŸ” DEBUG: window.existingVariants:', window.existingVariants);
            console.log('ğŸ” DEBUG: window.existingVariants length:', window.existingVariants ? window.existingVariants.length : 'undefined');
            
            if (!window.existingVariants || window.existingVariants.length === 0) {
                console.log('âŒ No existing variants to load');
                return;
            }
            
            // Check if variants table exists
            const variantsTableBody = document.getElementById('variantsTableBody');
            console.log('ğŸ” DEBUG: variantsTableBody element:', variantsTableBody);
            if (!variantsTableBody) {
                console.error('âŒ variantsTableBody element not found!');
                return;
            }
            
            // Enable variants section
            const hasVariantsCheckbox = document.getElementById('has_variants');
            const variantsContent = document.getElementById('variants-content');
            
            if (hasVariantsCheckbox && variantsContent) {
                hasVariantsCheckbox.checked = true;
                variantsContent.style.display = 'block';
                
                // Update toggle visual state
                const toggleSwitch = hasVariantsCheckbox.nextElementSibling;
                const toggleKnob = toggleSwitch.querySelector('span');
                if (toggleSwitch && toggleKnob) {
                    toggleSwitch.style.background = '#4CAF50';
                    toggleKnob.style.transform = 'translateX(25px)';
                }
                
                // âœ¨ CRITICAL: Trigger the toggle function to disable main image upload
                console.log('ğŸ”„ Triggering toggleVariantsSection to disable main image upload...');
                if (typeof window.toggleVariantsSection === 'function') {
                    window.toggleVariantsSection(hasVariantsCheckbox);
                } else {
                    console.error('âŒ toggleVariantsSection function not found!');
                }
            }
            
            // Show variants management section when loading existing variants
            const variantsManagement = document.getElementById('variantsManagement');
            if (variantsManagement) {
                variantsManagement.style.display = 'block';
                console.log('âœ… Showing variants management section for existing variants');
            }
            
            // âœ¨ NEW: Auto-select variant attributes based on existing variants
            console.log('ğŸ”„ Auto-selecting variant attributes based on existing variants...');
            console.log('ğŸ” DEBUG: About to call autoSelectVariantAttributes...');
            console.log('ğŸ” DEBUG: window.existingVariants before call:', window.existingVariants);
            // Add a longer delay to ensure category attributes are loaded
            setTimeout(() => {
                console.log('ğŸ” DEBUG: Calling autoSelectVariantAttributes now...');
                autoSelectVariantAttributes();
                // After auto-selecting, refresh the main attributes to hide variant attributes
                const categorySelect = document.getElementById('id_category');
                if (categorySelect && categorySelect.value && typeof window.loadCategoryAttributes === 'function') {
                    setTimeout(() => {
                        window.loadCategoryAttributes(categorySelect.value);
                        console.log('âœ… Main attributes refreshed after auto-selection');
                    }, 200);
                }
            }, 500);
            
            // Load variants into table
            if (variantsTableBody) {
                variantsTableBody.innerHTML = '';
                
                window.existingVariants.forEach((variant, index) => {
                    const row = document.createElement('tr');
                    
                    // Build attributes display from the attributes object
                    let attributesDisplay = '';
                    if (variant.attributes && typeof variant.attributes === 'object') {
                        const attributeKeys = Object.keys(variant.attributes);
                        if (attributeKeys.length > 0) {
                            attributeKeys.forEach((key, attrIndex) => {
                                const value = variant.attributes[key];
                                if (value) {
                                    // Different colors for different attribute types
                                    let bgColor = '#6c757d'; // default gray
                                    if (key.toLowerCase().includes('color') || key.toLowerCase().includes('Ø±Ù†Ú¯')) {
                                        bgColor = '#dc3545'; // red
                                    } else if (key.toLowerCase().includes('size') || key.toLowerCase().includes('Ø³Ø§ÛŒØ²')) {
                                        bgColor = '#007bff'; // blue
                                    } else if (key.toLowerCase().includes('material') || key.toLowerCase().includes('Ø¬Ù†Ø³')) {
                                        bgColor = '#28a745'; // green
                                    } else if (key.toLowerCase().includes('brand') || key.toLowerCase().includes('Ø¨Ø±Ù†Ø¯')) {
                                        bgColor = '#ffc107'; // yellow
                                    } else if (key.toLowerCase().includes('model') || key.toLowerCase().includes('Ù…Ø¯Ù„')) {
                                        bgColor = '#6f42c1'; // purple
                                    }
                                    
                                    attributesDisplay += `<span class="variant-attribute-badge" style="background: ${bgColor}; color: white; padding: 2px 6px; border-radius: 3px; font-size: 11px; margin-right: 5px; display: inline-block; margin-bottom: 2px;">
                                        <strong>${key}:</strong> ${value}
                                    </span>`;
                                }
                            });
                        }
                    }
                    
                    // Fallback to legacy fields if attributes object is empty
                    if (!attributesDisplay) {
                        if (variant.color) {
                            attributesDisplay += `<span class="variant-attribute-badge" style="background: #dc3545; color: white; padding: 2px 6px; border-radius: 3px; font-size: 11px; margin-right: 5px;">Ø±Ù†Ú¯: ${variant.color}</span>`;
                        }
                        if (variant.size) {
                            attributesDisplay += `<span class="variant-attribute-badge" style="background: #007bff; color: white; padding: 2px 6px; border-radius: 3px; font-size: 11px; margin-right: 5px;">Ø³Ø§ÛŒØ²: ${variant.size}</span>`;
                        }
                        if (variant.material) {
                            attributesDisplay += `<span class="variant-attribute-badge" style="background: #28a745; color: white; padding: 2px 6px; border-radius: 3px; font-size: 11px; margin-right: 5px;">Ø¬Ù†Ø³: ${variant.material}</span>`;
                        }
                    }
                    
                    // Show "Ù†Ø§Ù…Ø´Ø®Øµ" only if no attributes at all
                    if (!attributesDisplay) {
                        attributesDisplay = '<span style="color: #999; font-style: italic;">Ù†Ø§Ù…Ø´Ø®Øµ</span>';
                    }
                    
                        let statusText = variant.is_active ? 'ÙØ¹Ø§Ù„' : 'ØºÛŒØ±ÙØ¹Ø§Ù„';
                        if (variant.is_default) {
                            statusText += ' (Ù¾ÛŒØ´â€ŒÙØ±Ø¶)';
                        }
                        
                        row.innerHTML = `
                            <td><strong>${variant.sku}</strong></td>
                            <td>${attributesDisplay}</td>
                            <td>${variant.price_toman} ØªÙˆÙ…Ø§Ù†</td>
                            <td>${variant.stock_quantity}</td>
                            <td class="variant-status ${variant.is_active ? 'active' : 'inactive'}">
                                ${statusText}
                            </td>
                            <td class="variant-actions">
                                <button type="button" onclick="editVariant('${variant.id}'); return false;" class="btn btn-sm btn-primary">ÙˆÛŒØ±Ø§ÛŒØ´</button>
                                <button type="button" onclick="deleteVariant('${variant.id}'); return false;" class="btn btn-sm btn-danger">Ø­Ø°Ù</button>
                            </td>
                        `;
                    variantsTableBody.appendChild(row);
                });
                
                console.log(`âœ… Loaded ${window.existingVariants.length} existing variants`);
            }
        }

        // Function to auto-select variant attributes based on existing variants
        function autoSelectVariantAttributes() {
            console.log('ğŸ”„ autoSelectVariantAttributes called');
            console.log('ğŸ” window.existingVariants:', window.existingVariants);
            console.log('ğŸ” DEBUG: Raw existing variants data:', JSON.stringify(window.existingVariants, null, 2));
            
            if (!window.existingVariants || window.existingVariants.length === 0) {
                console.log('âŒ No existing variants to analyze');
                console.log('ğŸ” DEBUG: window.existingVariants value:', window.existingVariants);
                console.log('ğŸ” DEBUG: window.existingVariants type:', typeof window.existingVariants);
                console.log('ğŸ” DEBUG: window.existingVariants length:', window.existingVariants ? window.existingVariants.length : 'N/A');
                return;
            }
            
            // Collect all unique attribute keys from existing variants
            const usedAttributeKeys = new Set();
            window.existingVariants.forEach((variant, index) => {
                console.log(`ğŸ” Analyzing variant ${index + 1}:`, variant);
                console.log(`ğŸ” DEBUG: Variant ${index + 1} attributes:`, variant.attributes);
                console.log(`ğŸ” DEBUG: Variant ${index + 1} attributes type:`, typeof variant.attributes);
                console.log(`ğŸ” DEBUG: Variant ${index + 1} full object:`, JSON.stringify(variant, null, 2));
                
                // Check both attributes object and legacy fields
                let hasAttributes = false;
                
                // First check the attributes object
                if (variant.attributes && typeof variant.attributes === 'object') {
                    console.log(`ğŸ” DEBUG: Variant ${index + 1} has attributes object, keys:`, Object.keys(variant.attributes));
                    Object.keys(variant.attributes).forEach(key => {
                        console.log(`ğŸ” DEBUG: Checking attribute key "${key}":`, variant.attributes[key]);
                        console.log(`ğŸ” DEBUG: Attribute "${key}" value type:`, typeof variant.attributes[key]);
                        console.log(`ğŸ” DEBUG: Attribute "${key}" value length:`, variant.attributes[key] ? variant.attributes[key].length : 'N/A');
                        
                        if (variant.attributes[key] && variant.attributes[key].trim() !== '') {
                            usedAttributeKeys.add(key);
                            console.log(`âœ… Found attribute: ${key} = ${variant.attributes[key]}`);
                            hasAttributes = true;
                        } else {
                            console.log(`âŒ Skipping empty attribute: ${key} = "${variant.attributes[key]}"`);
                        }
                    });
                } else {
                    console.log(`âŒ Variant ${index + 1} has no attributes object or attributes is not an object`);
                    console.log(`âŒ Variant ${index + 1} attributes value:`, variant.attributes);
                    console.log(`âŒ Variant ${index + 1} attributes type:`, typeof variant.attributes);
                }
                
                // Also check legacy fields if no attributes object found
                if (!hasAttributes) {
                    console.log(`ğŸ” DEBUG: Checking legacy fields for variant ${index + 1}...`);
                    if (variant.color && variant.color.trim() !== '') {
                        usedAttributeKeys.add('color');
                        console.log(`âœ… Found legacy color: ${variant.color}`);
                    }
                    if (variant.size && variant.size.trim() !== '') {
                        usedAttributeKeys.add('size');
                        console.log(`âœ… Found legacy size: ${variant.size}`);
                    }
                    if (variant.material && variant.material.trim() !== '') {
                        usedAttributeKeys.add('material');
                        console.log(`âœ… Found legacy material: ${variant.material}`);
                    }
                }
                
                // ALWAYS check legacy fields as well, even if attributes object exists
                console.log(`ğŸ” DEBUG: Also checking legacy fields for variant ${index + 1}...`);
                if (variant.color && variant.color.trim() !== '') {
                    usedAttributeKeys.add('color');
                    console.log(`âœ… Found legacy color (additional check): ${variant.color}`);
                }
                if (variant.size && variant.size.trim() !== '') {
                    usedAttributeKeys.add('size');
                    console.log(`âœ… Found legacy size (additional check): ${variant.size}`);
                }
                if (variant.material && variant.material.trim() !== '') {
                    usedAttributeKeys.add('material');
                    console.log(`âœ… Found legacy material (additional check): ${variant.material}`);
                }
            });
            
            console.log('ğŸ” Found used attribute keys:', Array.from(usedAttributeKeys));
            console.log('ğŸ” DEBUG: Used attribute keys count:', usedAttributeKeys.size);
            console.log('ğŸ” DEBUG: Used attribute keys array:', Array.from(usedAttributeKeys));
            
            if (usedAttributeKeys.size === 0) {
                console.log('âŒ No valid attributes found in existing variants');
                return;
            }
            
            // Force load category attributes and then auto-select
            const categorySelect = document.getElementById('id_category');
            if (categorySelect && categorySelect.value) {
                console.log('ğŸ” Category selected:', categorySelect.value);
                // Load category attributes first
                if (typeof window.loadCategoryAttributes === 'function') {
                    window.loadCategoryAttributes(categorySelect.value);
                    
                    // Auto-select after a longer delay to ensure attributes are loaded
                    setTimeout(() => {
                        console.log('ğŸ” Attempting to auto-select attributes...');
                        console.log('ğŸ” DEBUG: Keys to auto-select:', Array.from(usedAttributeKeys));
                        selectVariantAttributesFromKeys(Array.from(usedAttributeKeys));
                    }, 1000);
                } else {
                    console.log('âŒ loadCategoryAttributes function not found');
                }
            } else {
                console.log('âŒ No category selected, cannot auto-select attributes');
            }
        }
        
        // Function to select variant attributes by their keys
        function selectVariantAttributesFromKeys(attributeKeys) {
            console.log('ğŸ”„ selectVariantAttributesFromKeys called with:', attributeKeys);
            
            const variantAttributesGrid = document.getElementById('variantAttributesGrid');
            if (!variantAttributesGrid) {
                console.log('âŒ Variant attributes grid not found');
                return;
            }
            
            console.log('ğŸ” Grid found, looking for attributes...');
            console.log('ğŸ” Grid children count:', variantAttributesGrid.children.length);
            
            let selectedCount = 0;
            attributeKeys.forEach(attrKey => {
                console.log(`ğŸ” Looking for attribute: ${attrKey}`);
                const attributeItem = variantAttributesGrid.querySelector(`[data-attribute="${attrKey}"]`);
                console.log(`ğŸ” Found attribute item:`, attributeItem);
                
                if (attributeItem) {
                    if (!attributeItem.classList.contains('selected')) {
                        // Simulate click to select the attribute (no checkbox needed)
                        console.log(`ğŸ” Selecting attribute: ${attrKey}`);
                        
                        // Add selected class and styling
                        attributeItem.classList.add('selected');
                        attributeItem.style.backgroundColor = '#28a745';
                        attributeItem.style.borderColor = '#1e7e34';
                        attributeItem.style.color = 'white';
                        attributeItem.style.fontWeight = 'bold';
                        attributeItem.style.transform = 'scale(1.05)';
                        
                        selectedCount++;
                        console.log(`âœ… Auto-selected attribute: ${attrKey}`);
                    } else {
                        console.log(`âœ… Attribute already selected: ${attrKey}`);
                        selectedCount++;
                    }
                } else {
                    console.log(`âŒ Attribute item not found: ${attrKey}`);
                }
            });
            
            if (selectedCount > 0) {
                console.log(`âœ… Auto-selected ${selectedCount} variant attributes`);
                
                // Update variant attributes form
                if (typeof window.updateVariantAttributesForm === 'function') {
                    window.updateVariantAttributesForm();
                }
                
                // Refresh main attributes to hide selected variant attributes
                refreshMainAttributes();
                
                // Update main attributes to hide variant attributes
                if (typeof window.updateMainAttributesOnly === 'function') {
                    window.updateMainAttributesOnly();
                }
            } else {
                console.log('âŒ No attributes were auto-selected');
            }
        }
        
        // Function to auto-select common variant attributes
        function autoSelectCommonVariantAttributes() {
            console.log('ğŸ”„ autoSelectCommonVariantAttributes called');
            
            // Common attribute keys that are good for variants
            const commonVariantKeys = ['color', 'size', 'material', 'brand', 'Ø¬Ù†Ø³ÛŒØª', 'Ø³Ø±ÛŒ', 'Ù†ÙˆØ¹ Ø­Ø±Ú©Øª'];
            
            // Get all available variant attribute items
            const allVariantItems = document.querySelectorAll('.variant-attribute-item');
            console.log('ğŸ” Found variant attribute items:', allVariantItems.length);
            
            let selectedCount = 0;
            
            allVariantItems.forEach(item => {
                const attrKey = item.getAttribute('data-attribute');
                console.log('ğŸ” Checking attribute:', attrKey);
                
                // Check if this is a common variant attribute
                if (commonVariantKeys.includes(attrKey)) {
                    console.log('âœ… Auto-selecting common attribute:', attrKey);
                    
                    // Select the attribute
                    item.classList.add('selected');
                    item.style.backgroundColor = '#28a745';
                    item.style.borderColor = '#1e7e34';
                    item.style.color = 'white';
                    item.style.fontWeight = 'bold';
                    item.style.transform = 'scale(1.05)';
                    
                    selectedCount++;
                    
                    // Stop after selecting 2-3 attributes to avoid overwhelming the user
                    if (selectedCount >= 2) {
                        return;
                    }
                }
            });
            
            console.log(`âœ… Auto-selected ${selectedCount} common variant attributes`);
            
            // Update the form after auto-selection
            if (selectedCount > 0) {
                updateMainAttributesOnly();
                refreshMainAttributes();
                updateVariantAttributesForm();
            }
        }
        
        // Function to validate variant attributes
        function validateVariantAttributes() {
            console.log('ğŸ”„ validateVariantAttributes called');
            console.log('ğŸ” DEBUG: Starting variant attributes validation...');
            
            const errors = [];
            
            // Get selected variant attributes
            let selectedVariantAttributes = getSelectedVariantAttributes();
            console.log('ğŸ” Selected variant attributes:', selectedVariantAttributes);
            console.log('ğŸ” DEBUG: Selected variant attribute keys:', selectedVariantAttributes.map(attr => attr.key));
            
            // If no attributes are selected, try to auto-select common ones
            if (selectedVariantAttributes.length === 0) {
                console.log('ğŸ”„ No variant attributes selected, attempting auto-selection...');
                autoSelectCommonVariantAttributes();
                
                // Check again after auto-selection
                selectedVariantAttributes = getSelectedVariantAttributes();
                console.log('ğŸ” After auto-selection:', selectedVariantAttributes);
            }
            
            if (selectedVariantAttributes.length === 0) {
                errors.push('Ø­Ø¯Ø§Ù‚Ù„ ÛŒÚ© ÙˆÛŒÚ˜Ú¯ÛŒ Ø¨Ø±Ø§ÛŒ Ù†ÙˆØ¹â€ŒÙ‡Ø§ÛŒ Ù…Ø­ØµÙˆÙ„ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯');
                return { isValid: false, errors };
            }
            
            // Get all variants from the table
            const variants = collectVariantDataFromTable();
            console.log('ğŸ” Collected variants:', variants);
            console.log('ğŸ” DEBUG: Number of variants collected:', variants.length);
            
            // If no variants are manually added, that's OK - the product can still be saved
            // with variant attributes selected for future variant creation
            if (variants.length === 0) {
                console.log('ğŸ” No variants manually added - this is OK, product can be saved with variant attributes');
                // Don't add error - allow saving with variant attributes but no specific variants
            }
            
            // Check each variant for missing required attributes
            variants.forEach((variant, index) => {
                const variantErrors = [];
                const variantNumber = index + 1;
                
                console.log(`ğŸ” DEBUG: Validating variant ${variantNumber}:`, {
                    sku: variant.sku,
                    attributes: variant.attributes,
                    selectedVariantAttributes: selectedVariantAttributes.map(attr => attr.key)
                });
                
                // Check if variant has all selected attributes
                selectedVariantAttributes.forEach(attr => {
                    const attrValue = variant.attributes && variant.attributes[attr.key];
                    console.log(`ğŸ” DEBUG: Checking attribute "${attr.key}":`, {
                        attrValue: attrValue,
                        isEmpty: !attrValue || attrValue.trim() === '',
                        variantSku: variant.sku
                    });
                    
                    if (!attrValue || attrValue.trim() === '') {
                        variantErrors.push(`Ù†ÙˆØ¹ ${variantNumber}: ÙˆÛŒÚ˜Ú¯ÛŒ "${attr.key}" Ø§Ù†ØªØ®Ø§Ø¨ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª`);
                        console.log(`âŒ DEBUG: Missing attribute "${attr.key}" for variant ${variantNumber}`);
                    } else {
                        console.log(`âœ… DEBUG: Attribute "${attr.key}" found for variant ${variantNumber}: "${attrValue}"`);
                    }
                });
                
                if (variantErrors.length > 0) {
                    errors.push(...variantErrors);
                    console.log(`âŒ DEBUG: Variant ${variantNumber} has errors:`, variantErrors);
                } else {
                    console.log(`âœ… DEBUG: Variant ${variantNumber} passed validation`);
                }
            });
            
            console.log('ğŸ” Validation result:', { isValid: errors.length === 0, errors });
            return { isValid: errors.length === 0, errors };
        }

        // Enhanced saveVariant function
        function saveVariant() {
            try {
                console.log('ğŸ¯ saveVariant() called - BUTTON CLICKED!');
                console.log('ğŸ¯ ==============================================');
                console.log('ğŸ¯ VARIANT SAVE PROCESS STARTED');
                console.log('ğŸ¯ ==============================================');
            
            // Check if we're editing an existing variant
            const variantIndex = document.getElementById('variantIndex')?.value;
            const modalTitle = document.getElementById('variantModalTitle')?.textContent;
            const isEditingByTitle = modalTitle && modalTitle.includes('ÙˆÛŒØ±Ø§ÛŒØ´');
            const isEditing = (variantIndex && variantIndex !== '' && variantIndex !== 'undefined' && !isNaN(parseInt(variantIndex))) || window.isEditingVariant || isEditingByTitle;
            
            console.log('ğŸ” DEBUG: variantIndex value:', variantIndex);
            console.log('ğŸ” DEBUG: modalTitle:', modalTitle);
            console.log('ğŸ” DEBUG: isEditingByTitle:', isEditingByTitle);
            console.log('ğŸ” DEBUG: window.isEditingVariant:', window.isEditingVariant);
            console.log('ğŸ” DEBUG: isEditing:', isEditing);
            console.log('ğŸ” DEBUG: variantIndex type:', typeof variantIndex);
            
            let sku = document.getElementById('variantSku')?.value?.trim();
            const price = document.getElementById('variantPriceToman')?.value?.replace(/,/g, '') || '0';
            const stock = parseInt(document.getElementById('variantStock')?.value) || 0;
            const isActive = document.getElementById('variantIsActive')?.checked || false;
            const isDefault = document.getElementById('variantIsDefault')?.checked || false;
            
            console.log('ğŸ” Variant data:', { sku, price, stock, isActive, isDefault, isEditing, variantIndex });
            
            if (!sku) {
                try {
                    const productName = document.getElementById('name')?.value || 'PRODUCT';
                    const generator = (window.ProductFormUtils && window.ProductFormUtils.generateSKU) ? window.ProductFormUtils.generateSKU : function(name){
                        const prefix = (name || 'PROD').substring(0,4).toUpperCase();
                        return prefix + '-' + Math.floor(Math.random()*10000);
                    };
                    sku = generator(productName, {});
                    const skuInput = document.getElementById('variantSku');
                    if (skuInput) skuInput.value = sku;
                    console.log('â„¹ï¸ SKU auto-generated:', sku);
                } catch (e) {
                    console.warn('âš ï¸ Failed to auto-generate SKU:', e);
                    alert('Ù„Ø·ÙØ§ Ú©Ø¯ SKU Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯');
                    return;
                }
            }
            
            // Collect attributes from the form
            const attributes = {};
            const attributeInputs = document.querySelectorAll('#variantAttributesForm input, #variantAttributesForm select');
            console.log('ğŸ” Found attribute inputs:', attributeInputs.length);
            
            attributeInputs.forEach(input => {
                console.log('ğŸ” Processing input:', {
                    name: input.name,
                    id: input.id,
                    value: input.value,
                    type: input.type
                });
                
                // Handle multiselect fields differently
                if (input.type === 'select-multiple' || (input.tagName === 'SELECT' && input.multiple)) {
                    // Get selected values for multiselect
                    const selectedValues = Array.from(input.selectedOptions).map(option => option.value);
                    if (selectedValues.length > 0) {
                        let attributeKey = '';
                        
                        if (input.name && input.name.startsWith('variant_attr_')) {
                            attributeKey = input.name.replace('variant_attr_', '');
                        } else if (input.name && input.name.startsWith('attr_')) {
                            attributeKey = input.name.replace('attr_', '');
                        } else if (input.id && input.id.startsWith('variant_attr_')) {
                            attributeKey = input.id.replace('variant_attr_', '');
                        } else if (input.id && input.id.startsWith('attr_')) {
                            attributeKey = input.id.replace('attr_', '');
                        } else {
                            const label = input.previousElementSibling?.textContent || input.name;
                            attributeKey = label.trim();
                        }
                        
                        console.log('ğŸ” Multiselect attribute key:', attributeKey, 'Values:', selectedValues);
                        attributes[attributeKey] = selectedValues.join(', ');
                    }
                } else if (input.value && input.value.trim()) {
                    // Get the attribute key from the field name or id
                    let attributeKey = '';
                    
                    if (input.name && input.name.startsWith('variant_attr_')) {
                        attributeKey = input.name.replace('variant_attr_', '');
                    } else if (input.name && input.name.startsWith('attr_')) {
                        attributeKey = input.name.replace('attr_', '');
                    } else if (input.id && input.id.startsWith('variant_attr_')) {
                        attributeKey = input.id.replace('variant_attr_', '');
                    } else if (input.id && input.id.startsWith('attr_')) {
                        attributeKey = input.id.replace('attr_', '');
                    } else {
                        // Try to get from label
                        const label = input.previousElementSibling?.textContent || input.name;
                        attributeKey = label.trim();
                    }
                    
                    console.log('ğŸ” Attribute key:', attributeKey, 'Value:', input.value.trim());
                    attributes[attributeKey] = input.value.trim();
                } else {
                    console.log('ğŸ” Input has no value:', input.name || input.id);
                }
            });
            
            console.log('ğŸ” Collected attributes:', attributes);
            
            // Check for duplicate SKU (only if not editing the same variant)
            if (!isEditing) {
                console.log('ğŸ” DEBUG: Creating new variant - checking for duplicate SKU');
                const existingRows = document.querySelectorAll('#variantsTableBody tr');
                for (let row of existingRows) {
                    if (row.cells[0].textContent.trim() === sku) {
                        alert('âŒ Ø§ÛŒÙ† Ú©Ø¯ SKU Ù‚Ø¨Ù„Ø§Ù‹ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø´Ø¯Ù‡ Ø§Ø³Øª');
                        return;
                    }
                }
            } else {
                console.log('ğŸ” DEBUG: Editing existing variant - SKIP SKU validation');
                console.log('ğŸ” DEBUG: Modal title:', document.getElementById('variantModalTitle')?.textContent);
                console.log('ğŸ” DEBUG: Global editing flag:', window.isEditingVariant);
                console.log('ğŸ” DEBUG: Editing variant ID:', window.editingVariantId);
                // SKIP SKU validation when editing - just proceed with save
            }
            
            // Collect variant images before adding to table
            const variantImages = [];
            const variantImageContainer = document.getElementById('variantImagePreviews');
            if (variantImageContainer) {
                const imageElements = variantImageContainer.querySelectorAll('.preview-item img');
                console.log(`ğŸ” Collecting ${imageElements.length} images for variant ${sku}`);
                
                imageElements.forEach((img, imgIndex) => {
                    // Convert image to base64 for transmission
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.naturalWidth || img.width;
                    canvas.height = img.naturalHeight || img.height;
                    ctx.drawImage(img, 0, 0);
                    const base64Image = canvas.toDataURL('image/jpeg', 0.8);
                    variantImages.push(base64Image);
                    console.log(`âœ… Collected image ${imgIndex} for variant ${sku}, base64 length: ${base64Image.length}`);
                });
            }
            
            // Store images for this variant
            variantState.variantImages[sku] = variantImages;
            console.log(`ğŸ’¾ Stored ${variantImages.length} images for variant ${sku}`);
            
            // Check if we're editing a table row
            const form = document.getElementById('variantForm');
            const isEditingTableRow = form && form.dataset.editingRow === 'true';
            
            if (isEditingTableRow) {
                // Update the existing table row
                const tbody = document.getElementById('variantsTableBody');
                const rows = tbody.querySelectorAll('tr');
                
                // Find the row that was being edited
                let targetRow = null;
                for (let row of rows) {
                    const editButton = row.querySelector('button[onclick*="editVariantFromTable"]');
                    if (editButton && editButton.closest('tr') === row) {
                        // Check if this row's SKU matches what we're editing
                        const rowSku = row.cells[0].textContent.trim();
                        if (rowSku === sku || form.dataset.rowElement.includes(rowSku)) {
                            targetRow = row;
                            break;
                        }
                    }
                }
                
                if (targetRow) {
                    // Update the row content
                    const attributesText = Object.entries(attributes)
                        .map(([key, value]) => `${key}: ${value}`)
                        .join(' ') || '-';
                    
                    const formattedPrice = parseInt(price).toLocaleString() + ' ØªÙˆÙ…Ø§Ù†';
                    let statusText = isActive ? 'ÙØ¹Ø§Ù„' : 'ØºÛŒØ±ÙØ¹Ø§Ù„';
                    if (isDefault) {
                        statusText += ' (Ù¾ÛŒØ´â€ŒÙØ±Ø¶)';
                    }
                    
                    targetRow.innerHTML = `
                        <td>${sku}</td>
                        <td>${attributesText}</td>
                        <td>${formattedPrice}</td>
                        <td>${stock}</td>
                        <td>${statusText}</td>
                        <td>
                            <button onclick="editVariantFromTable(this); return false;" style="background: #007bff; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; margin-right: 5px;">ÙˆÛŒØ±Ø§ÛŒØ´</button>
                            <button onclick="this.closest('tr').remove(); updateVariantState(); return false;" style="background: red; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer;">Ø­Ø°Ù</button>
                        </td>
                    `;
                    
                    console.log('âœ… Updated existing table row');
                }
                
                // Clear editing state
                form.dataset.editingRow = 'false';
                delete form.dataset.rowElement;
                
            } else if (isEditing) {
                // Update existing variant in the array
                if (window.existingVariants && window.existingVariants[variantIndex]) {
                    // If this variant is being set as default, unset all other defaults
                    if (isDefault) {
                        window.existingVariants.forEach((variant, index) => {
                            if (index != variantIndex) {
                                variant.is_default = false;
                            }
                        });
                    }
                    
                    window.existingVariants[variantIndex] = {
                        id: window.existingVariants[variantIndex].id, // Keep original ID
                        sku: sku,
                        attributes: attributes,
                        price_toman: parseFloat(price),
                        stock_quantity: stock,
                        is_active: isActive,
                        is_default: isDefault
                    };
                    
                    // Reload the variants table to reflect changes
                    loadExistingVariants();
                    console.log('âœ… Variant updated in existing variants array');
                }
            } else {
                // Add new variant to table
                const tbody = document.getElementById('variantsTableBody');
                const row = document.createElement('tr');
                
                // Check if this variant is being set as default, unset all other defaults
                const existingRows = tbody.querySelectorAll('tr');
                if (isDefault) {
                    Array.from(existingRows).forEach(existingRow => {
                        const statusCell = existingRow.cells[4];
                        if (statusCell && statusCell.textContent.includes('Ù¾ÛŒØ´â€ŒÙØ±Ø¶')) {
                            statusCell.textContent = statusCell.textContent.replace(' (Ù¾ÛŒØ´â€ŒÙØ±Ø¶)', '');
                        }
                    });
                }
                
                const attributesText = Object.entries(attributes)
                    .map(([key, value]) => `${key}: ${value}`)
                    .join(' ') || '-';
                
                const formattedPrice = parseInt(price).toLocaleString() + ' ØªÙˆÙ…Ø§Ù†';
                let statusText = isActive ? 'ÙØ¹Ø§Ù„' : 'ØºÛŒØ±ÙØ¹Ø§Ù„';
                if (isDefault) {
                    statusText += ' (Ù¾ÛŒØ´â€ŒÙØ±Ø¶)';
                }
                
                row.innerHTML = `
                    <td>${sku}</td>
                    <td>${attributesText}</td>
                    <td>${formattedPrice}</td>
                    <td>${stock}</td>
                    <td>${statusText}</td>
                    <td>
                        <button onclick="editVariantFromTable(this); return false;" style="background: #007bff; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; margin-right: 5px;">ÙˆÛŒØ±Ø§ÛŒØ´</button>
                        <button onclick="this.closest('tr').remove(); updateVariantState(); return false;" style="background: red; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer;">Ø­Ø°Ù</button>
                    </td>
                `;
                
                tbody.appendChild(row);
            }
            
            // Update variant state
            updateVariantState();
            
            // Close modal
            document.getElementById('variantModal').style.display = 'none';
            
            // Clear form and reset variant index
            document.getElementById('variantForm').reset();
            const variantIndexInput = document.getElementById('variantIndex');
            if (variantIndexInput) {
                variantIndexInput.value = '';
            }
            
            // Clear global editing flags
            window.isEditingVariant = false;
            window.editingVariantId = null;
            
            // Reset modal title
            const modalTitleElement = document.getElementById('variantModalTitle');
            if (modalTitleElement) {
                modalTitleElement.textContent = 'Ø§ÙØ²ÙˆØ¯Ù† Ù†ÙˆØ¹ Ù…Ø­ØµÙˆÙ„ Ø¬Ø¯ÛŒØ¯';
            }
            
            console.log('âœ… Variant saved successfully');
            console.log('ğŸ¯ ==============================================');
            console.log('ğŸ¯ VARIANT SAVE PROCESS COMPLETED!');
            console.log('ğŸ¯ ==============================================');
            
            // Show success message
            alert('âœ… Ù†ÙˆØ¹ Ù…Ø­ØµÙˆÙ„ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯!');
            
            // âœ¨ CRITICAL: Clear variant image upload area after successful save
            console.log('ğŸ§¹ Clearing variant image upload area after successful save...');
            clearVariantImageUpload();
            
            } catch (error) {
                console.error('âŒ Error in saveVariant function:', error);
                console.error('âŒ Error stack:', error.stack);
                alert('Ø®Ø·Ø§ Ø¯Ø± Ø°Ø®ÛŒØ±Ù‡ Ù†ÙˆØ¹ Ù…Ø­ØµÙˆÙ„: ' + error.message);
                
                // Still try to close the modal even if there's an error
                try {
                    document.getElementById('variantModal').style.display = 'none';
                } catch (e) {
                    console.error('âŒ Could not close modal:', e);
                }
            }
        }
        
        // Function to make slider clickable
        function makeSliderClickable() {
            const slider = document.querySelector('.slider.round');
            const checkbox = document.querySelector('#is_active');
            const statusText = document.getElementById('statusText');
            
            if (slider && checkbox) {
                slider.addEventListener('click', function() {
                    checkbox.checked = !checkbox.checked;
                    // Update status text
                    if (statusText) {
                        statusText.textContent = checkbox.checked ? 'ÙØ¹Ø§Ù„' : 'ØºÛŒØ±ÙØ¹Ø§Ù„';
                    }
                });
                
                // Make cursor pointer
                slider.style.cursor = 'pointer';
            }
        }

        // Function to update variant state
        function updateVariantState() {
            const variants = collectVariantDataFromTable();
            variantState.variants = variants;
            variantState.isEnabled = variants.length > 0;
            
            console.log('ğŸ”„ Variant state updated:', variantState);
        }
        
        // Function to open variant modal for adding - STABLE VERSION
        function openVariantModalForAdd() {
            console.log('ğŸ”§ openVariantModalForAdd called');
            console.log('ğŸ” Checking variant input state before opening modal...');
            const variantInput = document.getElementById('variantImageInput');
            console.log('ğŸ” Variant input found:', !!variantInput);
            console.log('ğŸ” Variant input disabled:', variantInput ? variantInput.disabled : 'N/A');
            const modal = document.getElementById('variantModal');
            const title = document.getElementById('variantModalTitle');
            const form = document.getElementById('variantForm');
            const index = document.getElementById('variantIndex');
            
            console.log('ğŸ”§ Modal element:', modal);
            console.log('ğŸ”§ Title element:', title);
            console.log('ğŸ”§ Form element:', form);
            console.log('ğŸ”§ Index element:', index);
            
            if (title) {
                title.textContent = 'Ø§ÙØ²ÙˆØ¯Ù† Ù†ÙˆØ¹ Ù…Ø­ØµÙˆÙ„ Ø¬Ø¯ÛŒØ¯';
            }
            if (index) {
                index.value = '';
            }
            
            // Clear variant image upload area when opening modal for new variant
            clearVariantImageUpload();
            if (form) {
                form.reset();
                // Pre-fill SKU automatically
                try {
                    const productName = document.getElementById('name')?.value || 'PRODUCT';
                    const generator = (window.ProductFormUtils && window.ProductFormUtils.generateSKU) ? window.ProductFormUtils.generateSKU : function(name){
                        const prefix = (name || 'PROD').substring(0,4).toUpperCase();
                        return prefix + '-' + Math.floor(Math.random()*10000);
                    };
                    const preSku = generator(productName, {});
                    const skuInput = document.getElementById('variantSku');
                    if (skuInput) skuInput.value = preSku;
                    console.log('â„¹ï¸ Prefilled SKU:', preSku);
                } catch (e) {
                    console.warn('âš ï¸ Could not prefill SKU:', e);
                }
            }
            
            // Update the variant attributes form before showing modal
            updateVariantAttributesForm();
            
            
            
            if (modal) {
                // Ensure modal stays open and prevent any auto-hide
                modal.style.display = 'block';
                modal.style.visibility = 'visible';
                modal.style.pointerEvents = 'auto';
                
                // Prevent modal from closing on mouse events
                modal.onmouseleave = null;
                modal.onmouseout = null;
                
                // Only allow explicit close
                modal.onclick = function(e) {
                    // Only close if clicked on the overlay (not the modal content)
                    if (e.target === modal) {
                        closeVariantModal();
                    }
                };
                
                console.log('âœ… Modal opened and stabilized');
                
                // Check variant input state after modal is opened
                const variantInputAfter = document.getElementById('variantImageInput');
                console.log('ğŸ” Variant input found after modal open:', !!variantInputAfter);
                console.log('ğŸ” Variant input disabled after modal open:', variantInputAfter ? variantInputAfter.disabled : 'N/A');
            } else {
                console.error('âŒ Modal element not found!');
            }
        }
        
        // Function to properly close the modal
        function closeVariantModal() {
            const modal = document.getElementById('variantModal');
            if (modal) {
                modal.style.display = 'none';
                console.log('âœ… Modal closed');
                
                // âœ¨ CRITICAL: Clear variant image upload area when modal closes
                console.log('ğŸ§¹ Clearing variant image upload area on modal close...');
                clearVariantImageUpload();
            }
        }
        
        // Function to get selected variant attributes
        function getSelectedVariantAttributes() {
            console.log('ğŸ” DEBUG: getSelectedVariantAttributes called');
            const selectedAttributes = [];
            const selectedItems = document.querySelectorAll('.variant-attribute-item.selected');
            
            console.log('ğŸ” Found selected items:', selectedItems.length);
            console.log('ğŸ” Selected items details:', Array.from(selectedItems).map(item => ({
                element: item,
                dataAttribute: item.getAttribute('data-attribute'),
                textContent: item.textContent?.trim()
            })));
            console.log('ğŸ” DEBUG: All variant attribute items:', document.querySelectorAll('.variant-attribute-item').length);
            console.log('ğŸ” DEBUG: Selected variant attribute items:', document.querySelectorAll('.variant-attribute-item.selected').length);
            
            selectedItems.forEach(item => {
                const attributeKey = item.getAttribute('data-attribute');
                console.log('ğŸ” Processing selected attribute:', attributeKey);
                
                // Find this attribute in the available category attributes
                const categoryId = document.getElementById('id_category')?.value;
                console.log('ğŸ” Category ID:', categoryId);
                console.log('ğŸ” Window categoryAttributes:', window.categoryAttributes);
                
                if (categoryId && window.categoryAttributes[categoryId]) {
                    const categoryAttrs = window.categoryAttributes[categoryId];
                    console.log('ğŸ” Category attributes for ID', categoryId, ':', categoryAttrs);
                    const matchingAttr = categoryAttrs.find(attr => attr.key === attributeKey);
                    
                    if (matchingAttr) {
                        console.log('âœ… Found matching attribute:', matchingAttr);
                        selectedAttributes.push(matchingAttr);
                    } else {
                        console.log('âŒ No matching attribute found for:', attributeKey);
                        console.log('ğŸ” Available attribute keys:', categoryAttrs.map(attr => attr.key));
                    }
                } else {
                    console.log('âŒ No category attributes found for category ID:', categoryId);
                }
            });
            
            console.log('ğŸ” Selected attributes result:', selectedAttributes);
            console.log('ğŸ” Selected attribute keys:', selectedAttributes.map(attr => attr.key));
            return selectedAttributes;
        }

        // Function to refresh main attributes when variant attributes change
        function refreshMainAttributes() {
            const categoryId = document.getElementById('id_category')?.value;
            if (categoryId) {
                console.log('ğŸ”„ Refreshing main attributes due to variant attribute change...');
                loadCategoryAttributes(categoryId);
            }
        }

        // Function to update selected variant attributes display
        function updateSelectedVariantAttributesDisplay() {
            const selectedAttributes = getSelectedVariantAttributes();
            const displayContainer = document.getElementById('selectedVariantAttributesDisplay');
            const listContainer = document.getElementById('selectedVariantAttributesList');
            
            if (displayContainer && listContainer) {
                if (selectedAttributes.length > 0) {
                    displayContainer.style.display = 'block';
                    listContainer.innerHTML = selectedAttributes.map(attr => 
                        `<span style="background: #4caf50; color: white; padding: 4px 8px; border-radius: 4px; font-size: 0.8rem;">${attr.key}</span>`
                    ).join('');
                } else {
                    displayContainer.style.display = 'none';
                }
            }
        }

        // Function to update variant attributes notice in main form
        function updateVariantAttributesNotice() {
            const selectedAttributes = getSelectedVariantAttributes();
            const noticeContainer = document.getElementById('variantAttributesNotice');
            const listContainer = document.getElementById('hiddenVariantAttributesList');
            
            if (noticeContainer && listContainer) {
                if (selectedAttributes.length > 0) {
                    noticeContainer.style.display = 'block';
                    listContainer.innerHTML = selectedAttributes.map(attr => 
                        `<span style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2px 6px; border-radius: 3px; margin-left: 4px; display: inline-block; margin-bottom: 2px;">${attr.key}</span>`
                    ).join('');
                } else {
                    noticeContainer.style.display = 'none';
                }
            }
        }
        
        // Function to handle distinctive attribute selection
        window.handleDistinctiveSelection = function(attrKey) {
            console.log('ğŸ¯ Distinctive attribute selected:', attrKey);
            
            // Radio buttons automatically deselect others, but let's log it
            const distinctiveRadios = document.querySelectorAll('.distinctive-radio');
            distinctiveRadios.forEach(radio => {
                if (radio.value === attrKey) {
                    console.log('âœ… Set as distinctive:', attrKey);
                } else if (radio.checked) {
                    console.log('âŒ Deselected as distinctive:', radio.value);
                }
            });
        };
        
        // MULTI-SELECT toggle function with CLEAR visual feedback - NO RE-RENDERING
        function toggleAttributeSelection(element, attrName) {
            console.log('ğŸ”„ TOGGLE:', attrName);
            
            // Toggle selection with VERY VISIBLE changes - INDEPENDENT of other cards
            if (element.classList.contains('selected')) {
                // DESELECT - Make it gray
                element.classList.remove('selected');
                element.style.backgroundColor = '#f8f9fa';
                element.style.borderColor = '#dee2e6';
                element.style.color = '#495057';
                element.style.fontWeight = 'normal';
                element.style.transform = 'scale(1)';
                console.log('âŒ DESELECTED:', attrName);
                
                // Uncheck the distinctive radio for this attribute
                const radio = element.querySelector('.distinctive-radio');
                if (radio) {
                    radio.checked = false;
                }
            } else {
                // SELECT - Make it GREEN and BOLD (DON'T affect other cards)
                element.classList.add('selected');
                element.style.backgroundColor = '#28a745';  // Strong green background
                element.style.borderColor = '#1e7e34';      // Dark green border
                element.style.color = 'white';              // White text
                element.style.fontWeight = 'bold';          // Bold text
                element.style.transform = 'scale(1.05)';    // Make it bigger
                console.log('âœ… SELECTED:', attrName);
            }
            
            // Count total selected for debugging
            const allSelected = document.querySelectorAll('.variant-attribute-item.selected');
            console.log(`ğŸ“Š Total selected: ${allSelected.length}`);
            allSelected.forEach((item, index) => {
                const attrKey = item.getAttribute('data-attribute');
                console.log(`   ${index + 1}. ${attrKey}`);
            });
            
            // âœ¨ AUTO-SELECT distinctive if only one attribute is selected
            if (allSelected.length === 1) {
                const radio = allSelected[0].querySelector('.distinctive-radio');
                if (radio && !radio.checked) {
                    radio.checked = true;
                    console.log('ğŸ¯ Auto-selected as distinctive (only one attribute):', attrName);
                }
            }
            
            // Update main attributes WITHOUT re-rendering variant cards
            updateMainAttributesOnly();
            
            // Refresh main attributes to hide/show selected variant attributes
            refreshMainAttributes();
            
            // Update variant form to show selected attributes
            updateVariantAttributesForm();
            
            // Update selected variant attributes display
            updateSelectedVariantAttributesDisplay();
            
            // Update variant attributes notice in main form
            updateVariantAttributesNotice();
            
            // âœ¨ Show/hide variant sections based on selection
            const variantsManagement = document.getElementById('variantsManagement');
            const variantGenerator = document.getElementById('variantGenerator');
            const selectedCount = document.querySelectorAll('.variant-attribute-item.selected').length;
            
            console.log('ğŸ” Checking variant sections visibility...');
            console.log('ğŸ” Selected count:', selectedCount);
            console.log('ğŸ” variantsManagement found:', !!variantsManagement);
            console.log('ğŸ” variantGenerator found:', !!variantGenerator);
            
            if (selectedCount > 0) {
                // Show both generator and management sections
                if (variantGenerator) {
                    variantGenerator.style.display = 'block';
                    console.log('âœ… Showing variant generator section');
                }
                if (variantsManagement) {
                    variantsManagement.style.display = 'block';
                    console.log('âœ… Showing variants management section');
                }
            } else {
                // Hide both sections when no attributes selected
                if (variantGenerator) {
                    variantGenerator.style.display = 'none';
                    console.log('âŒ Hiding variant generator section');
                }
                if (variantsManagement) {
                    variantsManagement.style.display = 'none';
                    console.log('âŒ Hiding variants management section');
                }
            }
        }
        
        // Update only main attributes without re-rendering variant cards
        function updateMainAttributesOnly() {
            const categorySelect = document.getElementById('id_category');
            if (!categorySelect || !categorySelect.value) return;
            
            const categoryId = categorySelect.value;
            
            // Get category attributes
            let categoryAttributesData = window.categoryAttributes[categoryId] || window.categoryAttributes[parseInt(categoryId)];
            if (!categoryAttributesData) {
                const availableKeys = Object.keys(window.categoryAttributes);
                const matchingKey = availableKeys.find(key => key == categoryId || key == parseInt(categoryId));
                if (matchingKey) {
                    categoryAttributesData = window.categoryAttributes[matchingKey];
                }
            }
            categoryAttributesData = categoryAttributesData || [];
            
            // Get selected variant attributes
            const selectedVariantAttributes = getSelectedVariantAttributes();
            const selectedVariantKeys = selectedVariantAttributes.map(attr => attr.key);
            
            // Filter out attributes that are used for variants
            const availableForMainAttributes = categoryAttributesData.filter(attr => {
                return !selectedVariantKeys.includes(attr.key);
            });
            
            // Update ONLY main attributes container (not variant cards)
            const attributesContainer = document.getElementById('attributes-container');
            if (attributesContainer) {
                if (availableForMainAttributes.length === 0) {
                    if (categoryAttributesData.length === 0) {
                        attributesContainer.innerHTML = `
                            <div class="empty-state">
                                <p>Ø¨Ø±Ø§ÛŒ Ø§ÛŒÙ† Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒØ§ÛŒ ØªØ¹Ø±ÛŒÙ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª.</p>
                                <p>Ù„Ø·ÙØ§ Ø¯Ø± Ù¾Ù†Ù„ Ù…Ø¯ÛŒØ±ÛŒØª ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø±Ø§ Ø§Ø¶Ø§ÙÙ‡ Ú©Ù†ÛŒØ¯.</p>
                            </div>
                        `;
                    } else {
                        attributesContainer.innerHTML = `
                            <div class="empty-state">
                                <p>Ù‡Ù…Ù‡ ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ø§ÛŒÙ† Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ø¨Ø±Ø§ÛŒ Ø§Ù†ÙˆØ§Ø¹ Ù…Ø­ØµÙˆÙ„ Ø§Ù†ØªØ®Ø§Ø¨ Ø´Ø¯Ù‡â€ŒØ§Ù†Ø¯.</p>
                                <p>Ø¨Ø±Ø§ÛŒ Ø§ÙØ²ÙˆØ¯Ù† ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ø¨ÛŒØ´ØªØ±ØŒ Ø§Ø¨ØªØ¯Ø§ Ø¨Ø±Ø®ÛŒ Ø§Ø² ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ù…ØªØºÛŒØ± Ø±Ø§ Ù„ØºÙˆ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯.</p>
                                <div style="margin-top: 10px; padding: 10px; background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px;">
                                    <strong>ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø´Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ Ø§Ù†ÙˆØ§Ø¹ Ù…Ø­ØµÙˆÙ„:</strong>
                                    <ul style="margin: 5px 0; padding-right: 20px;">
                                        ${selectedVariantKeys.map(key => `<li>${key}</li>`).join('')}
                                    </ul>
                                </div>
                            </div>
                        `;
                    }
                } else {
                    // Render filtered category attributes
                    let attributesHTML = '';
                    
                    // Add info about filtered attributes if any
                    if (selectedVariantKeys.length > 0) {
                        attributesHTML += `
                            <div style="margin-bottom: 15px; padding: 10px; background: #e3f2fd; border: 1px solid #90caf9; border-radius: 4px;">
                                <strong>â„¹ï¸ ØªÙˆØ¬Ù‡:</strong> ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ø²ÛŒØ± Ø¨Ø±Ø§ÛŒ Ø§Ù†ÙˆØ§Ø¹ Ù…Ø­ØµÙˆÙ„ Ø§Ù†ØªØ®Ø§Ø¨ Ø´Ø¯Ù‡â€ŒØ§Ù†Ø¯ Ùˆ Ø¯Ø± Ø§ÛŒÙ† Ø¨Ø®Ø´ Ù†Ù…Ø§ÛŒØ´ Ø¯Ø§Ø¯Ù‡ Ù†Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯:
                                <span style="color: #1976d2; font-weight: bold;">${selectedVariantKeys.join('ØŒ ')}</span>
                            </div>
                        `;
                    }
                    
                    // Render only via Django form-fields endpoint to keep names consistent and preserve values
                    loadDjangoFormFields(categoryId, availableForMainAttributes);
                }
            }
            
            console.log('âœ… Updated main attributes only - variant cards preserved');
        }
        
        // Function to update variant attributes form based on selected attributes
        function updateVariantAttributesForm() {
            console.log('ğŸ”„ Updating variant attributes form...');
            console.log('ğŸ” DEBUG: updateVariantAttributesForm called');
            
            const variantAttributesForm = document.getElementById('variantAttributesForm');
            if (!variantAttributesForm) {
                console.log('âŒ Variant attributes form not found');
                console.log('ğŸ” DEBUG: variantAttributesForm element:', variantAttributesForm);
                return;
            }
            
            const selectedAttributes = getSelectedVariantAttributes();
            console.log('ğŸ”§ Selected attributes for form:', selectedAttributes);
            console.log('ğŸ”§ Number of selected attributes:', selectedAttributes.length);
            console.log('ğŸ” DEBUG: selectedAttributes details:', selectedAttributes.map(attr => ({ key: attr.key, type: attr.type, values: attr.values })));
            console.log('ğŸ” DEBUG: getSelectedVariantAttributes function result:', selectedAttributes);
            
            // Clear any existing dynamic fields to prevent duplication
            const existingDynamicFields = variantAttributesForm.querySelectorAll('.dynamic-variant-field');
            existingDynamicFields.forEach(field => field.remove());
            console.log(`ğŸ§¹ Cleared ${existingDynamicFields.length} existing dynamic variant fields`);
            
            if (selectedAttributes.length === 0) {
                variantAttributesForm.innerHTML = `
                    <div class="form-group">
                        <p style="color: #6c757d; text-align: center; padding: 1rem; background: #f8f9fa; border-radius: 8px; border: 1px solid #dee2e6;">
                            Ø§Ø¨ØªØ¯Ø§ ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ù…ØªØºÛŒØ± Ø±Ø§ Ø§Ø² Ø¨Ø§Ù„Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯
                        </p>
                    </div>
                `;
                console.log('âŒ No attributes selected - showing placeholder');
            } else {
                // Render only the selected attributes
                let attributesHTML = `
                    <div style="margin-bottom: 15px; padding: 10px; background: #d4edda; border: 1px solid #c3e6cb; border-radius: 8px;">
                        <strong>âœ… ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ø´Ø¯Ù‡:</strong> ${selectedAttributes.map(attr => attr.key).join('ØŒ ')}
                    </div>
                `;
                
                selectedAttributes.forEach(attr => {
                    const fieldName = `variant_attr_${attr.key}`;
                    const isRequired = attr.required ? 'required' : '';
                    
                    console.log('ğŸ”§ Creating form field for attribute:', {
                        key: attr.key,
                        fieldName: fieldName,
                        type: attr.type,
                        values: attr.values
                    });
                    
                    if (attr.type === 'select') {
                        attributesHTML += `
                            <div class="form-group dynamic-variant-field" style="display: inline-block; width: 150px; margin-right: 1rem; margin-bottom: 1rem; vertical-align: top; border: 1px solid #ddd; padding: 0.5rem; border-radius: 8px; background: transparent;">
                                <label for="${fieldName}" style="font-size: 0.8rem; font-weight: bold; margin-bottom: 0.3rem; display: block;">${attr.key}</label>
                                <select name="${fieldName}" id="${fieldName}" class="form-control" ${isRequired} style="width: 100%; padding: 0.3rem; font-size: 0.8rem;">
                                    <option value="">Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯...</option>
                                    ${attr.values.map(value => `<option value="${value}">${value}</option>`).join('')}
                                </select>
                            </div>
                        `;
                    } else if (attr.type === 'multiselect') {
                        attributesHTML += `
                            <div class="form-group dynamic-variant-field" style="display: inline-block; width: 150px; margin-right: 1rem; margin-bottom: 1rem; vertical-align: top; border: 1px solid #ddd; padding: 0.5rem; border-radius: 8px; background: transparent;">
                                <label for="${fieldName}" style="font-size: 0.8rem; font-weight: bold; margin-bottom: 0.3rem; display: block;">${attr.key}</label>
                                <select name="${fieldName}" id="${fieldName}" class="form-control" multiple ${isRequired} style="width: 100%; padding: 0.3rem; font-size: 0.8rem; min-height: 60px;">
                                    ${attr.values.map(value => `<option value="${value}">${value}</option>`).join('')}
                                </select>
                            </div>
                        `;
                    }
                });
                
                variantAttributesForm.innerHTML = attributesHTML;
                console.log('âœ… Variant attributes form updated with selected attributes');
                console.log('ğŸ”§ Number of fields created:', selectedAttributes.length);
                console.log('ğŸ”§ Generated HTML length:', attributesHTML.length);
                console.log('ğŸ” DEBUG: Generated HTML content:', attributesHTML);
                console.log('ğŸ” DEBUG: Form element after update:', variantAttributesForm);
                console.log('ğŸ” DEBUG: All inputs in form after update:', Array.from(variantAttributesForm.querySelectorAll('input, select')).map(el => ({ id: el.id, name: el.name, type: el.type })));
            }
        }
        
        // Toggle functionality for variants section
        function toggleVariantsSection(checkbox) {
            console.log('ğŸ”„ Toggling variants section:', checkbox.checked);
            const content = document.getElementById('variants-content');
            const toggleSwitch = checkbox.nextElementSibling;
            const toggleKnob = toggleSwitch.querySelector('span');
            
            if (content) {
                content.style.display = checkbox.checked ? 'block' : 'none';
            }
            
            // Update toggle visual state
            if (checkbox.checked) {
                toggleSwitch.style.background = '#4CAF50';
                toggleKnob.style.transform = 'translateX(25px)';
                
                // âœ¨ When variants are enabled, refresh category attributes to filter out variant attributes
                console.log('ğŸ”„ Variants enabled - filtering category attributes...');
                const categorySelect = document.getElementById('id_category');
                if (categorySelect && categorySelect.value && typeof window.loadCategoryAttributes === 'function') {
                    // Add a small delay to ensure the variants section is visible
                    setTimeout(() => {
                        window.loadCategoryAttributes(categorySelect.value);
                        console.log('âœ… Category attributes refreshed to hide variant attributes');
                        
                        // Also update the variant form
                        updateVariantAttributesForm();
                    }, 100);
                }
                
                // Update variant attributes display
                updateSelectedVariantAttributesDisplay();
                updateVariantAttributesNotice();
                
                // Update main image section description and disable main image upload
                const mainImageDesc = document.getElementById('mainImageDescription');
                if (mainImageDesc) {
                    mainImageDesc.textContent = 'ØªØµØ§ÙˆÛŒØ± Ù…Ø´ØªØ±Ú© Ø¨Ø±Ø§ÛŒ Ù‡Ù…Ù‡ Ø§Ù†ÙˆØ§Ø¹ Ù…Ø­ØµÙˆÙ„. Ø¨Ø±Ø§ÛŒ ØªØµØ§ÙˆÛŒØ± Ù…Ø®ØµÙˆØµ Ù‡Ø± Ù†ÙˆØ¹ØŒ Ø§Ø² Ø¨Ø®Ø´ "Ø§Ù†ÙˆØ§Ø¹ Ù…Ø­ØµÙˆÙ„" Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯';
                }
                
                // Disable main image upload section
                const mainImageInput = document.getElementById('imageInput');
                const mainImageSection = document.querySelector('.image-section');
                console.log('ğŸ” Main image input found:', !!mainImageInput);
                console.log('ğŸ” Main image section found:', !!mainImageSection);
                
                if (mainImageInput) {
                    mainImageInput.disabled = true;
                    console.log('âœ… Main image input disabled');
                } else {
                    console.error('âŒ Main image input not found!');
                }
                
                if (mainImageSection) {
                    const uploadArea = mainImageSection.querySelector('.upload-area');
                    console.log('ğŸ” Upload area found:', !!uploadArea);
                    if (uploadArea) {
                        uploadArea.style.opacity = '0.5';
                        uploadArea.style.cursor = 'not-allowed';
                        uploadArea.style.pointerEvents = 'none';
                        console.log('âœ… Main upload area disabled');
                    } else {
                        console.error('âŒ Upload area not found in main image section!');
                    }
                } else {
                    console.error('âŒ Main image section not found!');
                }
                
                // Enable variant modal image upload section
                const variantModal = document.getElementById('variantModal');
                console.log('ğŸ” Variant modal found:', !!variantModal);
                
                if (variantModal) {
                    const variantImageInput = variantModal.querySelector('#variantImageInput');
                    const variantUploadArea = variantModal.querySelector('.upload-area');
                    console.log('ğŸ” Variant image input found:', !!variantImageInput);
                    console.log('ğŸ” Variant upload area found:', !!variantUploadArea);
                    
                    if (variantImageInput) {
                        variantImageInput.disabled = false;
                        console.log('âœ… Variant image input enabled');
                    } else {
                        console.error('âŒ Variant image input not found!');
                    }
                    
                    if (variantUploadArea) {
                        variantUploadArea.style.opacity = '1';
                        variantUploadArea.style.cursor = 'pointer';
                        variantUploadArea.style.pointerEvents = 'auto';
                        console.log('âœ… Variant upload area enabled');
                    } else {
                        console.error('âŒ Variant upload area not found!');
                    }
                } else {
                    console.error('âŒ Variant modal not found!');
                }
            } else {
                toggleSwitch.style.background = '#ccc';
                toggleKnob.style.transform = 'translateX(0)';
                
                // âœ¨ NEW: Clear all selected attributes when variants are disabled
                console.log('ğŸ”„ Clearing all selected variant attributes...');
                const selectedAttributes = document.querySelectorAll('.variant-attribute-item.selected');
                selectedAttributes.forEach(item => {
                    const itemCheckbox = item.querySelector('input[type="checkbox"]');
                    if (itemCheckbox) {
                        itemCheckbox.checked = false;
                    }
                    item.classList.remove('selected');
                    console.log('âœ… Cleared attribute:', item.querySelector('.variant-attribute-name')?.textContent);
                });
                
                // Hide variants management section since no attributes are selected
                const variantsManagement = document.getElementById('variantsManagement');
                if (variantsManagement) {
                    variantsManagement.style.display = 'none';
                    console.log('âœ… Hidden variants management section');
                }
                
                // âœ¨ When variants are disabled, show ALL category attributes
                console.log('ğŸ”„ Variants disabled - showing all category attributes...');
                const categorySelect = document.getElementById('id_category');
                if (categorySelect && categorySelect.value && typeof window.loadCategoryAttributes === 'function') {
                    window.loadCategoryAttributes(categorySelect.value);
                    console.log('âœ… All category attributes displayed');
                }
                
                // Hide variant attributes display
                updateSelectedVariantAttributesDisplay();
                updateVariantAttributesNotice();
                
                // Update main image section description and restore main image upload
                const mainImageDesc = document.getElementById('mainImageDescription');
                if (mainImageDesc) {
                    mainImageDesc.textContent = 'ØªØµØ§ÙˆÛŒØ± Ø§ØµÙ„ÛŒ Ú©Ù‡ Ø¨Ø±Ø§ÛŒ Ù‡Ù…Ù‡ Ø§Ù†ÙˆØ§Ø¹ Ù…Ø­ØµÙˆÙ„ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯';
                }
                
                // Restore main image upload section
                const mainImageInput = document.getElementById('imageInput');
                const mainImageSection = document.querySelector('.image-section');
                console.log('ğŸ” Restoring main image input found:', !!mainImageInput);
                console.log('ğŸ” Restoring main image section found:', !!mainImageSection);
                
                if (mainImageInput) {
                    mainImageInput.disabled = false;
                    console.log('âœ… Main image input restored');
                } else {
                    console.error('âŒ Main image input not found for restoration!');
                }
                
                if (mainImageSection) {
                    const uploadArea = mainImageSection.querySelector('.upload-area');
                    console.log('ğŸ” Restoring upload area found:', !!uploadArea);
                    if (uploadArea) {
                        uploadArea.style.opacity = '1';
                        uploadArea.style.cursor = 'pointer';
                        uploadArea.style.pointerEvents = 'auto';
                        console.log('âœ… Main upload area restored');
                    } else {
                        console.error('âŒ Upload area not found for restoration!');
                    }
                } else {
                    console.error('âŒ Main image section not found for restoration!');
                }
                
                // Switch back to main container when variants are disabled
                currentContainer = mainContainer;
                console.log('âœ… Switched back to main container');
                
                // Disable variant modal image upload section
                const variantModal = document.getElementById('variantModal');
                console.log('ğŸ” Disabling variant modal found:', !!variantModal);
                
                if (variantModal) {
                    const variantImageInput = variantModal.querySelector('#variantImageInput');
                    const variantUploadArea = variantModal.querySelector('.upload-area');
                    console.log('ğŸ” Disabling variant image input found:', !!variantImageInput);
                    console.log('ğŸ” Disabling variant upload area found:', !!variantUploadArea);
                    
                    if (variantImageInput) {
                        variantImageInput.disabled = true;
                        console.log('âœ… Variant image input disabled');
                    } else {
                        console.error('âŒ Variant image input not found for disabling!');
                    }
                    
                    if (variantUploadArea) {
                        variantUploadArea.style.opacity = '0.5';
                        variantUploadArea.style.cursor = 'not-allowed';
                        variantUploadArea.style.pointerEvents = 'none';
                        console.log('âœ… Variant upload area disabled');
                    } else {
                        console.error('âŒ Variant upload area not found for disabling!');
                    }
                } else {
                    console.error('âŒ Variant modal not found for disabling!');
                }
                
                console.log('âœ… All variant attributes cleared successfully');

                // Ensure any hidden variant_attributes input is removed when variants are disabled
                try {
                    const formEl = document.getElementById('product_form');
                    const staleVariantAttrs = formEl ? formEl.querySelector('input[name="variant_attributes"]') : null;
                    if (staleVariantAttrs) {
                        staleVariantAttrs.parentNode.removeChild(staleVariantAttrs);
                        console.log('ğŸ§¹ Removed stale hidden input variant_attributes');
                    }
                } catch (e) {
                    console.warn('âš ï¸ Could not remove stale variant_attributes input:', e);
                }
            }

            // Dynamically toggle required attribute for fields inside the variants section
            try {
                if (content) {
                    const variantFields = content.querySelectorAll('input, select, textarea');
                    variantFields.forEach(field => {
                        if (checkbox.checked) {
                            // Keep existing required state, do nothing
                            return;
                        } else {
                            // When variants are disabled, temporarily mark as not required
                            if (field.hasAttribute('required')) {
                                field.setAttribute('data-was-required', '1');
                                field.removeAttribute('required');
                            }
                        }
                    });

                    if (checkbox.checked) {
                        // Restore required where it was
                        const toRestore = content.querySelectorAll('[data-was-required="1"]');
                        toRestore.forEach(field => {
                            field.setAttribute('required', '');
                            field.removeAttribute('data-was-required');
                        });
                    }
                }
            } catch (e) {
                console.warn('âš ï¸ Error toggling required attributes for variants:', e);
            }
        }
        
            // Global form submission handler
        function handleSaveClick(button) {
            console.log('ğŸ”˜ Save button clicked:', button.value);
            console.log('ğŸ”˜ Button element:', button);
            
            // Get the form
            const form = document.getElementById('product_form');
            console.log('ğŸ”˜ Form element:', form);
            
            if (form) {
                console.log('ğŸ”˜ Form action:', form.action);
                console.log('ğŸ”˜ Form method:', form.method);
                
                    // Check required fields
                    let requiredFields = Array.from(form.querySelectorAll('[required]'));

                    // If variants are enabled, exclude variant attributes from main form validation
                    const hasVariantsCheckbox = document.getElementById('has_variants');
                    const variantsEnabled = hasVariantsCheckbox && hasVariantsCheckbox.checked;
                    const variantsContent = document.getElementById('variants-content');
                    const attributesContainer = document.getElementById('attributes-container');
                    
                    if (variantsEnabled) {
                        // Exclude variant attributes from main form validation
                        const selectedVariantAttributes = getSelectedVariantAttributes();
                        const selectedVariantKeys = selectedVariantAttributes.map(attr => attr.key);
                        
                        requiredFields = requiredFields.filter(field => {
                            // Check if this field is a variant attribute
                            const fieldName = field.name || field.id || '';
                            console.log('ğŸ” Checking field for variant exclusion:', {
                                fieldName: fieldName,
                                selectedVariantKeys: selectedVariantKeys,
                                fieldType: field.type
                            });
                            
                            const isVariantAttribute = selectedVariantKeys.some(key => {
                                const attrPattern = `attr_${key}`;
                                const variantAttrPattern = `variant_attr_${key}`;
                                const matches = fieldName.includes(attrPattern) || fieldName.includes(variantAttrPattern);
                                console.log('ğŸ” Pattern matching:', {
                                    key: key,
                                    attrPattern: attrPattern,
                                    variantAttrPattern: variantAttrPattern,
                                    matches: matches
                                });
                                return matches;
                            });
                            
                            if (isVariantAttribute) {
                                console.log('ğŸ” Excluding variant attribute from main form validation:', fieldName);
                                return false;
                            }
                            console.log('ğŸ” Keeping field in validation:', fieldName);
                            return true;
                        });
                    } else if (variantsContent) {
                        // If variants are disabled, exclude fields inside variants section
                        requiredFields = requiredFields.filter(f => !variantsContent.contains(f));
                    }

                    // Also exclude fields that are not visible (e.g., display:none)
                    requiredFields = requiredFields.filter(f => {
                        const style = window.getComputedStyle(f);
                        const isVisible = style.display !== 'none' && style.visibility !== 'hidden';
                        // Ensure all ancestors are visible too
                        let node = f;
                        while (node && node !== document.body) {
                            const cs = window.getComputedStyle(node);
                            if (cs.display === 'none' || cs.visibility === 'hidden') return false;
                            node = node.parentElement;
                        }
                        return isVisible;
                    });
                console.log('ğŸ”˜ Required fields found:', requiredFields.length);
                console.log('ğŸ”˜ Required fields:', Array.from(requiredFields).map(f => ({name: f.name, id: f.id, value: f.value, type: f.type})));
                
                let hasErrors = false;
                let emptyFields = [];
                
                requiredFields.forEach(field => {
                    console.log(`ğŸ” Checking field: ${field.name || field.id} (${field.type}) = "${field.value}"`);
                    
                    if (!field.value || !field.value.trim()) {
                        console.log('âŒ Required field empty:', field.name, field.id, field.type);
                        field.style.borderColor = 'red';
                        field.style.backgroundColor = '#ffe6e6';
                        hasErrors = true;
                        
                        // Get field label or name for better error message
                        let fieldLabel = field.name || field.id || 'Unknown field';
                        const label = form.querySelector(`label[for="${field.id}"]`);
                        if (label) {
                            fieldLabel = label.textContent.trim();
                        }
                        emptyFields.push(fieldLabel);
                        console.log('âŒ Added to empty fields:', fieldLabel);
                    } else {
                        console.log('âœ… Field has value:', field.name || field.id);
                        field.style.borderColor = '';
                        field.style.backgroundColor = '';
                    }
                });
                
                console.log('ğŸ”˜ Has errors:', hasErrors);
                console.log('ğŸ”˜ Empty fields list:', emptyFields);
                
                if (hasErrors) {
                    const errorMessage = `Ù„Ø·ÙØ§ ÙÛŒÙ„Ø¯Ù‡Ø§ÛŒ Ø²ÛŒØ± Ø±Ø§ Ù¾Ø± Ú©Ù†ÛŒØ¯:\n\n${emptyFields.join('\n')}`;
                    console.log('ğŸš¨ Showing error message:', errorMessage);
                    alert(errorMessage);
                    return false;
                }
                
                // âœ¨ NEW: Validate variant attributes before saving
                if (variantsEnabled) {
                    console.log('ğŸ”„ Validating variant attributes...');
                    const variantValidation = validateVariantAttributes();
                    if (!variantValidation.isValid) {
                        console.log('âŒ Variant validation failed:', variantValidation.errors);
                        alert(`Ø®Ø·Ø§ Ø¯Ø± Ù†ÙˆØ¹â€ŒÙ‡Ø§ÛŒ Ù…Ø­ØµÙˆÙ„:\n\n${variantValidation.errors.join('\n')}`);
                        
                        // âœ¨ CRITICAL: Reset form state after validation error to ensure edit buttons work
                        console.log('ğŸ”„ Resetting form state after validation error...');
                        resetFormStateAfterValidationError();
                        
                        return false;
                    }
                    console.log('âœ… Variant validation passed');
                }
                
                // Add variant attributes to form data
                if (variantsEnabled) {
                    const selectedVariantAttributes = getSelectedVariantAttributes();
                    const selectedVariantKeys = selectedVariantAttributes.map(attr => attr.key);
                    
                    console.log('ğŸ”§ DEBUG: variantsEnabled:', variantsEnabled);
                    console.log('ğŸ”§ DEBUG: selectedVariantAttributes:', selectedVariantAttributes);
                    console.log('ğŸ”§ DEBUG: selectedVariantKeys:', selectedVariantKeys);
                    
                    if (selectedVariantKeys.length > 0) {
                        // Create or update hidden input for variant attributes
                        let variantAttrsInput = form.querySelector('input[name="variant_attributes"]');
                        if (!variantAttrsInput) {
                            variantAttrsInput = document.createElement('input');
                            variantAttrsInput.type = 'hidden';
                            variantAttrsInput.name = 'variant_attributes';
                            form.appendChild(variantAttrsInput);
                            console.log('ğŸ”§ DEBUG: Created new variant_attributes input');
                        } else {
                            console.log('ğŸ”§ DEBUG: Using existing variant_attributes input');
                        }
                        variantAttrsInput.value = JSON.stringify(selectedVariantKeys);
                        console.log('ğŸ”§ Added variant attributes to form data:', selectedVariantKeys);
                        console.log('ğŸ”§ DEBUG: variant_attributes input value:', variantAttrsInput.value);
                        
                        // Verify the input is in the form
                        const verifyInput = form.querySelector('input[name="variant_attributes"]');
                        console.log('ğŸ”§ DEBUG: Verification - variant_attributes input found:', !!verifyInput);
                        console.log('ğŸ”§ DEBUG: Verification - variant_attributes input value:', verifyInput ? verifyInput.value : 'NOT FOUND');
                    } else {
                        console.log('ğŸ”§ DEBUG: No variant attributes selected, not adding to form');
                    }
                } else {
                    console.log('ğŸ”§ DEBUG: Variants not enabled, not adding variant attributes');
                    // Remove any lingering hidden input so backend doesn't treat attributes as variants
                    try {
                        const stale = form.querySelector('input[name="variant_attributes"]');
                        if (stale) {
                            stale.parentNode.removeChild(stale);
                            console.log('ğŸ§¹ Removed lingering variant_attributes input before submit');
                        }
                    } catch (e) {
                        console.warn('âš ï¸ Could not remove lingering variant_attributes input:', e);
                    }
                }
                
                // Try to add variant data if function exists
                if (typeof addVariantDataToForm === 'function') {
                    console.log('ğŸ”„ Adding variant data to form');
                    try {
                        addVariantDataToForm();
                        console.log('âœ… addVariantDataToForm completed successfully');
                        
                        // âœ¨ CRITICAL: Verify the data was actually added to the form
                        const form = document.getElementById('product_form');
                        const variantsDataInput = form.querySelector('input[name="variants_data"]');
                        if (variantsDataInput) {
                            console.log('âœ… Variants data input found in form');
                            console.log('âœ… Variants data value length:', variantsDataInput.value.length);
                            try {
                                const parsedData = JSON.parse(variantsDataInput.value);
                                console.log('âœ… Variants data parsed successfully, count:', parsedData.length);
                                parsedData.forEach((variant, index) => {
                                    console.log(`âœ… Variant ${index + 1} (${variant.sku}) has ${variant.images ? variant.images.length : 0} images`);
                                });
                            } catch (e) {
                                console.error('âŒ Error parsing variants data:', e);
                            }
                        } else {
                            console.error('âŒ Variants data input NOT found in form!');
                        }
                    } catch (e) {
                        console.log('âš ï¸ Error adding variant data:', e);
                        console.error('âš ï¸ Error stack:', e.stack);
                    }
                } else {
                    console.log('âš ï¸ addVariantDataToForm function not found');
                }
                
                console.log('ğŸ“¤ About to submit form...');
                
                // Final verification of form data before submission
                console.log('ğŸ” FINAL FORM DATA VERIFICATION:');
                const finalFormData = new FormData(form);
                for (let [key, value] of finalFormData.entries()) {
                    if (key.includes('variant') || key.includes('attr_')) {
                        console.log(`ğŸ” ${key}: ${value}`);
                    }
                }
                
                // Check for variant_attributes specifically
                const finalVariantAttrsInput = form.querySelector('input[name="variant_attributes"]');
                console.log('ğŸ” Final variant_attributes input:', finalVariantAttrsInput);
                console.log('ğŸ” Final variant_attributes value:', finalVariantAttrsInput ? finalVariantAttrsInput.value : 'NOT FOUND');
                
                // Don't submit programmatically - let the normal form submission handle it
                console.log('âœ… All validations passed, allowing form submission');
                return true; // Allow normal form submission
            } else {
                console.log('âŒ Form not found!');
                return false;
            }
        }
        
        
        
        
        // Function to test attribute collection
        function testAttributeCollection() {
            console.log('ğŸ§ª Testing attribute collection...');
            
            const variantAttributesForm = document.getElementById('variantAttributesForm');
            if (!variantAttributesForm) {
                console.log('âŒ Variant attributes form not found');
                return;
            }
            
            const attributeInputs = variantAttributesForm.querySelectorAll('input, select');
            console.log('ğŸ” Found inputs in variant form:', attributeInputs.length);
            
            attributeInputs.forEach((input, index) => {
                console.log(`ğŸ” Input ${index + 1}:`, {
                    name: input.name,
                    id: input.id,
                    value: input.value,
                    type: input.type,
                    tagName: input.tagName
                });
                
                if (input.value) {
                    console.log(`âœ… Input ${index + 1} has value: "${input.value}"`);
                } else {
                    console.log(`âŒ Input ${index + 1} has no value`);
                }
            });
            
            // Test the collection logic
            const attributes = {};
            attributeInputs.forEach(input => {
                if (input.value && input.value.trim()) {
                    let attributeKey = '';
                    
                    if (input.name && input.name.startsWith('attr_')) {
                        attributeKey = input.name.replace('attr_', '');
                    } else if (input.id && input.id.startsWith('attr_')) {
                        attributeKey = input.id.replace('attr_', '');
                    } else {
                        const label = input.previousElementSibling?.textContent || input.name;
                        attributeKey = label.trim();
                    }
                    
                    attributes[attributeKey] = input.value.trim();
                }
            });
            
            console.log('ğŸ” Collected attributes:', attributes);
            alert(`Collected attributes: ${JSON.stringify(attributes, null, 2)}`);
        }
        
        // Make functions global
        window.addVariantDataToForm = addVariantDataToForm;
        window.saveVariant = saveVariant;
        window.openVariantModalForAdd = openVariantModalForAdd;
        window.updateVariantState = updateVariantState;
        window.collectVariantDataFromTable = collectVariantDataFromTable;
        window.toggleAttributeSelection = toggleAttributeSelection;
        window.toggleVariantsSection = toggleVariantsSection;
        window.handleSaveClick = handleSaveClick;
        window.getSelectedVariantAttributes = getSelectedVariantAttributes;
        window.updateVariantAttributesForm = updateVariantAttributesForm;
        window.updateSelectedVariantAttributesDisplay = updateSelectedVariantAttributesDisplay;
        window.updateVariantAttributesNotice = updateVariantAttributesNotice;
        window.testAttributeCollection = testAttributeCollection;
        window.renderAttributeSelectionGrid = renderAttributeSelectionGrid;
        window.loadExistingVariants = loadExistingVariants;
        window.autoSelectVariantAttributes = autoSelectVariantAttributes;
        window.selectVariantAttributesFromKeys = selectVariantAttributesFromKeys;
        window.validateVariantAttributes = validateVariantAttributes;
        window.updateMainAttributesOnly = updateMainAttributesOnly;
        
        // Function to reset form state after validation error
        function resetFormStateAfterValidationError() {
            console.log('ğŸ”„ resetFormStateAfterValidationError called');
            
            // Reset variant modal state
            const modal = document.getElementById('variantModal');
            if (modal) {
                modal.style.display = 'none';
                console.log('âœ… Variant modal closed');
            }
            
            // Clear variant form
            const variantForm = document.getElementById('variantForm');
            if (variantForm) {
                variantForm.reset();
                console.log('âœ… Variant form reset');
            }
            
            // Reset variant index
            const variantIndexInput = document.getElementById('variantIndex');
            if (variantIndexInput) {
                variantIndexInput.value = '';
                console.log('âœ… Variant index reset');
            }
            
            // Clear global editing flags
            window.isEditingVariant = false;
            window.editingVariantId = null;
            console.log('âœ… Global editing flags cleared');
            
            // Reset modal title
            const modalTitleElement = document.getElementById('variantModalTitle');
            if (modalTitleElement) {
                modalTitleElement.textContent = 'Ø§ÙØ²ÙˆØ¯Ù† Ù†ÙˆØ¹ Ù…Ø­ØµÙˆÙ„ Ø¬Ø¯ÛŒØ¯';
                console.log('âœ… Modal title reset');
            }
            
            // Clear form dataset
            if (variantForm) {
                delete variantForm.dataset.editingRow;
                delete variantForm.dataset.rowElement;
                console.log('âœ… Form dataset cleared');
            }
            
            // Ensure variant table is properly rendered
            if (typeof window.loadExistingVariants === 'function') {
                window.loadExistingVariants();
                console.log('âœ… Variant table refreshed');
            }
            
            // âœ¨ CRITICAL: Ensure button styles are consistent after reset
            setTimeout(() => {
                const editButtons = document.querySelectorAll('button[onclick*="editVariant"], button[onclick*="editVariantFromTable"]');
                editButtons.forEach(button => {
                    // Ensure consistent styling
                    if (button.textContent.trim() === 'ÙˆÛŒØ±Ø§ÛŒØ´') {
                        button.className = 'btn btn-sm btn-primary';
                        button.style.cssText = 'background: #007bff; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; margin-right: 5px;';
                    }
                });
                console.log('âœ… Button styles reset to consistent format');
            }, 100);
            
            console.log('âœ… Form state reset completed');
        }
        
        window.resetFormStateAfterValidationError = resetFormStateAfterValidationError;
        
        
        
        
        
        // Function to load Django form fields dynamically
        function loadDjangoFormFields(categoryId, availableAttributes) {
            console.log('ğŸ”„ Loading Django form fields for category:', categoryId);
            
            // Snapshot current values to preserve user selections on re-render
            const attributesContainer = document.getElementById('attributes-container');
            const snapshot = {};
            if (attributesContainer) {
                const inputs = attributesContainer.querySelectorAll('input[name^="attr_"], select[name^="attr_"]');
                inputs.forEach(el => {
                    const name = el.name;
                    if (!name) return;
                    if (el.tagName === 'SELECT') {
                        if (el.multiple) {
                            snapshot[name] = Array.from(el.selectedOptions).map(o => o.value);
                        } else {
                            snapshot[name] = el.value;
                        }
                    } else if (el.type === 'checkbox') {
                        snapshot[name] = el.checked;
                    } else {
                        snapshot[name] = el.value;
                    }
                });
                // Clear before fetch/insert
                attributesContainer.innerHTML = '';
                console.log('ğŸ§¹ Cleared attributes-container before inserting new fields (snapshot size):', Object.keys(snapshot).length);
            }
            
            fetch(`${window.location.origin}/suppliers/api/category/${categoryId}/form-fields/`, {
                method: 'GET',
                credentials: 'same-origin',
                headers: {
                    'Accept': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest',
                    'Cache-Control': 'no-cache'
                },
                redirect: 'follow',
                mode: 'same-origin'
            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.success) {
                        console.log('âœ… Django form fields loaded:', data.attribute_fields);
                        createDjangoAttributeFields(data.attribute_fields, availableAttributes, snapshot);
                    } else {
                        console.error('âŒ Failed to load Django form fields:', data.error);
                        // Fallback to creating dynamic fields
                        createDynamicAttributeFields(availableAttributes, snapshot);
                    }
                })
                .catch(error => {
                    console.error('âŒ Error loading Django form fields:', error);
                    // Fallback to creating dynamic fields
                    createDynamicAttributeFields(availableAttributes, snapshot);
                });
        }
        
        // Function to create Django attribute fields
        function createDjangoAttributeFields(djangoFields, availableAttributes, snapshot = {}) {
            const attributesContainer = document.getElementById('attributes-container');
            if (!attributesContainer) return;
            
            // Hard reset the container to guarantee no duplicates remain
            attributesContainer.innerHTML = '';
            
            // Create fields for available attributes
            availableAttributes.forEach(attr => {
                const fieldData = djangoFields[attr.key];
                if (fieldData) {
                    const fieldDiv = document.createElement('div');
                    fieldDiv.className = 'form-group attribute-field dynamic-attribute-field';
                    fieldDiv.setAttribute('data-attribute-key', attr.key);
                    fieldDiv.style.cssText = 'display: inline-block; width: 150px; margin-right: 1rem; margin-bottom: 1rem; vertical-align: top; border: 1px solid #ddd; padding: 0.5rem; border-radius: 8px; background: transparent;';
                    
                    const label = document.createElement('label');
                    label.setAttribute('for', fieldData.name);
                    label.style.cssText = 'font-size: 0.8rem; font-weight: bold; margin-bottom: 0.3rem; display: block;';
                    label.innerHTML = fieldData.label + (fieldData.required ? '<span style="color: red;">*</span>' : '');
                    
                    let input;
                    if (fieldData.field_type === 'ChoiceField') {
                        input = document.createElement('select');
                        input.name = fieldData.name;
                        input.className = 'form-control';
                        input.id = fieldData.name;
                        
                        // Add empty option
                        const emptyOption = document.createElement('option');
                        emptyOption.value = '';
                        emptyOption.textContent = 'Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯';
                        input.appendChild(emptyOption);
                        
                        // Add choices
                        if (fieldData.choices) {
                            fieldData.choices.forEach(choice => {
                                const option = document.createElement('option');
                                option.value = choice[0];
                                option.textContent = choice[1];
                                // Prefer snapshot, then existingAttrs, then initial
                                const snapVal = snapshot[fieldData.name];
                                let existingVal = undefined;
                                try {
                                    const key = fieldData.name.startsWith('attr_') ? fieldData.name.substring(5) : fieldData.name;
                                    existingVal = (window.existingAttrs || {})[key];
                                } catch (_) {}
                                if (snapVal !== undefined) {
                                    if (Array.isArray(snapVal)) {
                                        option.selected = snapVal.includes(choice[0]);
                                    } else {
                                        option.selected = String(snapVal) === String(choice[0]);
                                    }
                                } else if (existingVal !== undefined && existingVal !== null && String(existingVal) !== '') {
                                    option.selected = String(existingVal) === String(choice[0]);
                                } else if (fieldData.initial === choice[0]) {
                                    option.selected = true;
                                }
                                input.appendChild(option);
                            });
                        }
                    } else if (fieldData.field_type === 'MultipleChoiceField') {
                        input = document.createElement('select');
                        input.name = fieldData.name;
                        input.className = 'form-control';
                        input.id = fieldData.name;
                        input.multiple = true;
                        
                        // Add choices
                        if (fieldData.choices) {
                            fieldData.choices.forEach(choice => {
                                const option = document.createElement('option');
                                option.value = choice[0];
                                option.textContent = choice[1];
                                const snapVal = snapshot[fieldData.name];
                                let existingVals = undefined;
                                try {
                                    const key = fieldData.name.startsWith('attr_') ? fieldData.name.substring(5) : fieldData.name;
                                    const raw = (window.existingAttrs || {})[key];
                                    if (Array.isArray(raw)) existingVals = raw;
                                    else if (typeof raw === 'string') existingVals = raw.split(',').map(v => v.trim()).filter(Boolean);
                                } catch (_) {}
                                if (snapVal !== undefined) {
                                    const arr = Array.isArray(snapVal) ? snapVal : [snapVal];
                                    option.selected = arr.some(v => String(v) === String(choice[0]));
                                } else if (existingVals && existingVals.length) {
                                    option.selected = existingVals.some(v => String(v) === String(choice[0]));
                                } else if (fieldData.initial && fieldData.initial.includes(choice[0])) {
                                    option.selected = true;
                                }
                                input.appendChild(option);
                            });
                        }
                    } else {
                        input = document.createElement('input');
                        input.type = fieldData.field_type === 'DecimalField' ? 'number' : 'text';
                        input.name = fieldData.name;
                        input.className = 'form-control';
                        input.id = fieldData.name;
                        const snapVal = snapshot[fieldData.name];
                        let existingVal = undefined;
                        try {
                            const key = fieldData.name.startsWith('attr_') ? fieldData.name.substring(5) : fieldData.name;
                            existingVal = (window.existingAttrs || {})[key];
                        } catch (_) {}
                        if (snapVal !== undefined) {
                            if (typeof snapVal === 'boolean') {
                                input.checked = !!snapVal;
                            } else {
                                input.value = snapVal;
                            }
                        } else if (existingVal !== undefined && existingVal !== null && String(existingVal) !== '') {
                            input.value = existingVal;
                        } else if (fieldData.initial) {
                            input.value = fieldData.initial;
                        }
                    }
                    
                    fieldDiv.appendChild(label);
                    fieldDiv.appendChild(input);
                    
                    // Add debug info
                    const debugDiv = document.createElement('div');
                    debugDiv.style.cssText = 'font-size: 10px; color: #666; margin-top: 2px;';
                    debugDiv.textContent = `Debug: ${fieldData.name}`;
                    fieldDiv.appendChild(debugDiv);
                    
                    attributesContainer.appendChild(fieldDiv);
                    console.log(`âœ… Created Django field for attribute: ${attr.key}`);
                }
            });
        }
        
        // Function to create dynamic attribute fields (fallback)
        function createDynamicAttributeFields(availableAttributes, snapshot = {}) {
            const attributesContainer = document.getElementById('attributes-container');
            if (!attributesContainer) return;
            
            console.log('ğŸ”§ Creating dynamic attribute fields for:', availableAttributes.map(attr => attr.key));
            
            // Hard reset container to avoid any duplication
            attributesContainer.innerHTML = '';
            
            availableAttributes.forEach(attr => {
                const fieldDiv = document.createElement('div');
                fieldDiv.className = 'form-group attribute-field dynamic-attribute-field';
                fieldDiv.setAttribute('data-attribute-key', attr.key);
                fieldDiv.style.cssText = 'display: inline-block; width: 150px; margin-right: 1rem; margin-bottom: 1rem; vertical-align: top; border: 1px solid #ddd; padding: 0.5rem; border-radius: 8px; background: transparent;';
                
                const label = document.createElement('label');
                label.style.cssText = 'font-size: 0.8rem; font-weight: bold; margin-bottom: 0.3rem; display: block;';
                label.innerHTML = attr.key + (attr.required ? '<span style="color: red;">*</span>' : '');
                
                let input;
                if (attr.type === 'select') {
                    input = document.createElement('select');
                    input.name = `attr_${attr.key}`;
                    input.className = 'form-control';
                    input.id = `attr_${attr.key}`;
                    
                    // Add empty option
                    const emptyOption = document.createElement('option');
                    emptyOption.value = '';
                    emptyOption.textContent = 'Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯';
                    input.appendChild(emptyOption);
                    
                    // Add values
                    if (attr.values && attr.values.length > 0) {
                        attr.values.forEach(value => {
                            const option = document.createElement('option');
                            option.value = value;
                            option.textContent = value;
                            const snapVal = snapshot[`attr_${attr.key}`];
                            if (snapVal !== undefined) {
                                if (Array.isArray(snapVal)) {
                                    option.selected = snapVal.includes(value);
                                } else {
                                    option.selected = String(snapVal) === String(value);
                                }
                            }
                            input.appendChild(option);
                        });
                    }
                } else if (attr.type === 'multiselect') {
                    input = document.createElement('select');
                    input.name = `attr_${attr.key}`;
                    input.className = 'form-control';
                    input.multiple = true;
                    input.id = `attr_${attr.key}`;
                    
                    // Add values
                    if (attr.values && attr.values.length > 0) {
                        attr.values.forEach(value => {
                            const option = document.createElement('option');
                            option.value = value;
                            option.textContent = value;
                            const snapVal = snapshot[`attr_${attr.key}`];
                            if (snapVal !== undefined) {
                                const arr = Array.isArray(snapVal) ? snapVal : [snapVal];
                                option.selected = arr.some(v => String(v) === String(value));
                            }
                            input.appendChild(option);
                        });
                    }
                } else if (attr.type === 'number') {
                    input = document.createElement('input');
                    input.type = 'number';
                    input.name = `attr_${attr.key}`;
                    input.className = 'form-control';
                    input.id = `attr_${attr.key}`;
                    const snapVal = snapshot[`attr_${attr.key}`];
                    if (snapVal !== undefined) input.value = snapVal;
                } else if (attr.type === 'boolean') {
                    input = document.createElement('input');
                    input.type = 'checkbox';
                    input.name = `attr_${attr.key}`;
                    input.className = 'form-control';
                    input.id = `attr_${attr.key}`;
                    const snapVal = snapshot[`attr_${attr.key}`];
                    if (snapVal !== undefined) input.checked = !!snapVal;
                } else {
                    input = document.createElement('input');
                    input.type = 'text';
                    input.name = `attr_${attr.key}`;
                    input.className = 'form-control';
                    input.id = `attr_${attr.key}`;
                    const snapVal = snapshot[`attr_${attr.key}`];
                    if (snapVal !== undefined) input.value = snapVal;
                }
                
                fieldDiv.appendChild(label);
                fieldDiv.appendChild(input);
                
                // Add debug info
                const debugDiv = document.createElement('div');
                debugDiv.style.cssText = 'font-size: 10px; color: #666; margin-top: 2px;';
                debugDiv.textContent = `Debug: attr_${attr.key}`;
                fieldDiv.appendChild(debugDiv);
                
                attributesContainer.appendChild(fieldDiv);
                console.log(`âœ… Created dynamic field for attribute: ${attr.key}`);
            });
        }
        
        // Load available attributes for the selected category - GLOBAL FUNCTION
        window.loadCategoryAttributes = function(categoryId) {
            console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            console.log('ğŸš€ loadCategoryAttributes CALLED');
            console.log('ğŸ” Input categoryId:', categoryId);
            console.log('ğŸ” categoryId type:', typeof categoryId);
            console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            
            // ERROR CHECKING
            if (!categoryId) {
                console.error('âŒ FATAL: categoryId is null/undefined!');
                return;
            }
            
            if (!window.categoryAttributes) {
                console.error('âŒ FATAL: window.categoryAttributes is not loaded!');
                console.error('âŒ window.categoryAttributes value:', window.categoryAttributes);
                return;
            }
            
            if (typeof window.categoryAttributes !== 'object') {
                console.error('âŒ FATAL: window.categoryAttributes is not an object!', typeof window.categoryAttributes);
                return;
            }
            
            console.log('âœ… window.categoryAttributes is loaded and is an object');
            console.log('ğŸ” Available category IDs in window.categoryAttributes:', Object.keys(window.categoryAttributes));
            console.log('ğŸ” Total categories:', Object.keys(window.categoryAttributes).length);
            
            // Get category attributes from existing data
            console.log('ğŸ” Attempting to find attributes for category:', categoryId);
            console.log('ğŸ” Direct lookup [categoryId]:', window.categoryAttributes[categoryId]);
            console.log('ğŸ” parseInt lookup [parseInt(categoryId)]:', window.categoryAttributes[parseInt(categoryId)]);
            
            let categoryAttributesData = window.categoryAttributes[categoryId] || window.categoryAttributes[parseInt(categoryId)];
            
            // If still not found, try to find by matching the key
            if (!categoryAttributesData) {
                console.warn('âš ï¸ WARNING: No direct match found for categoryId:', categoryId);
                const availableKeys = Object.keys(window.categoryAttributes);
                console.log('ğŸ” Available keys:', availableKeys);
                console.log('ğŸ” Searching for matching key...');
                
                const matchingKey = availableKeys.find(key => {
                    const matches = key == categoryId || key == parseInt(categoryId);
                    console.log(`ğŸ” Comparing key "${key}" with categoryId "${categoryId}": ${matches}`);
                    return matches;
                });
                
                if (matchingKey) {
                    categoryAttributesData = window.categoryAttributes[matchingKey];
                    console.log('âœ… Found matching key:', matchingKey);
                    console.log('âœ… Attributes for matching key:', categoryAttributesData);
                } else {
                    console.error('âŒ FATAL: No matching key found for categoryId:', categoryId);
                    console.error('âŒ This means category', categoryId, 'has no attributes defined in the backend');
                    
                    // Show empty state
                    const attributesContainer = document.getElementById('attributes-container');
                    if (attributesContainer) {
                        attributesContainer.innerHTML = `
                            <div class="empty-state" style="padding: 20px; text-align: center; color: #999;">
                                <p>âŒ Ø§ÛŒÙ† Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ù‡ÛŒÚ† ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒØ§ÛŒ Ù†Ø¯Ø§Ø±Ø¯</p>
                                <p style="font-size: 12px;">Category ID: ${categoryId}</p>
                            </div>
                        `;
                    }
                    return;
                }
            }
            
            categoryAttributesData = categoryAttributesData || [];
            console.log('âœ… Final categoryAttributesData:', categoryAttributesData);
            console.log('âœ… Number of attributes:', categoryAttributesData.length);
            console.log('ğŸ”§ Category attributes data:', categoryAttributesData);
            
            // Check if variants are enabled and get selected variant attributes
            const variantToggle = document.getElementById('has_variants');
            const variantsEnabled = variantToggle && variantToggle.checked;
            let selectedVariantKeys = [];
            
            if (variantsEnabled) {
                const selectedVariantAttributes = getSelectedVariantAttributes();
                selectedVariantKeys = selectedVariantAttributes.map(attr => attr.key);
                console.log('ğŸ”§ Selected variant attribute keys:', selectedVariantKeys);
            }
            
            console.log('ğŸ”§ All category attributes before filtering:', categoryAttributesData.map(attr => attr.key));
            
            // Filter out attributes that are used for variants - COMPLETELY HIDE THEM
            const availableForMainAttributes = categoryAttributesData.filter(attr => {
                const isUsedForVariant = variantsEnabled && selectedVariantKeys.includes(attr.key);
                console.log(`ğŸ”§ Attribute "${attr.key}" used for variant:`, isUsedForVariant, '- WILL BE HIDDEN FROM MAIN FORM');
                return !isUsedForVariant;
            });
            
                    console.log('ğŸ”§ Available for main attributes after filtering:', availableForMainAttributes.map(attr => attr.key));
            
            // Remove any existing attr_ fields for variant attributes that should be hidden
            selectedVariantKeys.forEach(key => {
                const existingField = document.querySelector(`[name="attr_${key}"]`);
                if (existingField) {
                    console.log(`ğŸ—‘ï¸ Removing existing attr_${key} field from DOM`);
                    const parentDiv = existingField.closest('.form-group') || existingField.parentElement;
                    if (parentDiv) {
                        parentDiv.remove();
                    } else {
                        existingField.remove();
                    }
                }
            });
            
            console.log('ğŸ”§ Available for main attributes:', availableForMainAttributes);
            
            // WORK WITH EXISTING DJANGO FORM FIELDS INSTEAD OF REPLACING THEM
            const attributesContainer = document.getElementById('attributes-container');
            if (attributesContainer) {
                // Ensure a clean slate before showing/hiding
                attributesContainer.innerHTML = '';
                console.log('ğŸ”§ Working with existing Django form fields instead of replacing them');
                
                // We no longer rely on pre-rendered Django fields; fetch or build once
                loadDjangoFormFields(categoryId, availableForMainAttributes);
                
                // Show info about hidden variant attributes if any
                if (selectedVariantKeys.length > 0) {
                    // Check if info div already exists
                    let infoDiv = document.getElementById('variant-attributes-info');
                    if (!infoDiv) {
                        infoDiv = document.createElement('div');
                        infoDiv.id = 'variant-attributes-info';
                        infoDiv.style.cssText = 'margin-bottom: 15px; padding: 10px; background: #e3f2fd; border: 1px solid #90caf9; border-radius: 4px;';
                        infoDiv.innerHTML = `
                            <strong>â„¹ï¸ ØªÙˆØ¬Ù‡:</strong> ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ø²ÛŒØ± Ø¨Ø±Ø§ÛŒ Ø§Ù†ÙˆØ§Ø¹ Ù…Ø­ØµÙˆÙ„ Ø§Ù†ØªØ®Ø§Ø¨ Ø´Ø¯Ù‡â€ŒØ§Ù†Ø¯ Ùˆ Ø¯Ø± Ø§ÛŒÙ† Ø¨Ø®Ø´ Ù†Ù…Ø§ÛŒØ´ Ø¯Ø§Ø¯Ù‡ Ù†Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯:
                            <span style="color: #1976d2; font-weight: bold;">${selectedVariantKeys.join('ØŒ ')}</span>
                        `;
                        attributesContainer.insertBefore(infoDiv, attributesContainer.firstChild);
                    }
                } else {
                    // Remove info div if no variant attributes
                    const infoDiv = document.getElementById('variant-attributes-info');
                    if (infoDiv) {
                        infoDiv.remove();
                    }
                }
                
                console.log('âœ… Django form fields visibility updated');
            } else {
                console.log('âŒ attributes-container not found');
            }
            
                // Update variant attributes notice after loading category attributes
                updateVariantAttributesNotice();
                
                // Update variant form if variants are enabled
                const hasVariantsCheckbox = document.getElementById('has_variants');
                if (hasVariantsCheckbox && hasVariantsCheckbox.checked) {
                    console.log('ğŸ”§ Variants enabled - updating variant form');
                    updateVariantAttributesForm();
                }
            
            // Filter for variant-suitable attributes (only select/multiselect)
            const variantAttributes = categoryAttributesData.filter(attr => {
                const isVariantType = ['select', 'multiselect'].includes(attr.type);
                const hasValues = attr.values && attr.values.length > 0;
                console.log(`ğŸ”§ Attribute ${attr.key}: type=${attr.type}, hasValues=${hasValues}, values=${attr.values}`);
                return isVariantType && hasValues;
            });
            
            console.log('ğŸ”§ Filtered variant attributes:', variantAttributes);
            console.log('ğŸ”§ Total category attributes:', categoryAttributesData.length);
            
            // Update the variant attributes form
            const variantAttributesForm = document.getElementById('variantAttributesForm');
            if (variantAttributesForm) {
                if (variantAttributes.length === 0) {
                    variantAttributesForm.innerHTML = `
                        <div class="form-group">
                            <p style="color: var(--text-secondary); text-align: center; padding: 1rem;">
                                Ø¨Ø±Ø§ÛŒ Ø§ÛŒÙ† Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ù…Ù†Ø§Ø³Ø¨ Ø¨Ø±Ø§ÛŒ ØªÙ†ÙˆØ¹ Ù…Ø­ØµÙˆÙ„ ÛŒØ§ÙØª Ù†Ø´Ø¯.
                                Ù„Ø·ÙØ§ Ø¯Ø± Ù¾Ù†Ù„ Ù…Ø¯ÛŒØ±ÛŒØª ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒÛŒ Ø§Ø² Ù†ÙˆØ¹ "Single Selection" ÛŒØ§ "Multiple Selection" Ø¨Ø§ Ù…Ù‚Ø§Ø¯ÛŒØ± ØªØ¹Ø±ÛŒÙ Ø´Ø¯Ù‡ Ø§Ø¶Ø§ÙÙ‡ Ú©Ù†ÛŒØ¯.
                            </p>
                        </div>
                    `;
                } else {
                    // Only show attributes that are selected for variants
                    const selectedAttributes = getSelectedVariantAttributes();
                    console.log('ğŸ”§ Selected variant attributes:', selectedAttributes);
                    
                    if (selectedAttributes.length === 0) {
                        variantAttributesForm.innerHTML = `
                            <div class="form-group">
                                <p style="color: var(--text-secondary); text-align: center; padding: 1rem;">
                                    Ø§Ø¨ØªØ¯Ø§ ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ù…ØªØºÛŒØ± Ø±Ø§ Ø§Ø² Ø¨Ø§Ù„Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯
                                </p>
                            </div>
                        `;
                    } else {
                        // Render only the selected attributes
                        let attributesHTML = `
                            <div style="margin-bottom: 15px; padding: 10px; background: #d4edda; border: 1px solid #c3e6cb; border-radius: 8px;">
                                <strong>âœ… ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ø´Ø¯Ù‡:</strong> ${selectedAttributes.map(attr => attr.key).join('ØŒ ')}
                            </div>
                        `;
                        
                        selectedAttributes.forEach(attr => {
                            const fieldName = `variant_attr_${attr.key}`;
                            const isRequired = attr.required ? 'required' : '';
                            
                            if (attr.type === 'select') {
                                attributesHTML += `
                                    <div class="form-group dynamic-variant-field" style="display: inline-block; width: 150px; margin-right: 1rem; margin-bottom: 1rem; vertical-align: top; border: 1px solid #ddd; padding: 0.5rem; border-radius: 8px; background: transparent;">
                                        <label for="${fieldName}" style="font-size: 0.8rem; font-weight: bold; margin-bottom: 0.3rem; display: block;">${attr.key}</label>
                                        <select name="${fieldName}" id="${fieldName}" class="form-control" ${isRequired} style="width: 100%; padding: 0.3rem; font-size: 0.8rem;">
                                            <option value="">Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯...</option>
                                            ${attr.values.map(value => `<option value="${value}">${value}</option>`).join('')}
                                        </select>
                                    </div>
                                `;
                            } else if (attr.type === 'multiselect') {
                                attributesHTML += `
                                    <div class="form-group dynamic-variant-field" style="display: inline-block; width: 150px; margin-right: 1rem; margin-bottom: 1rem; vertical-align: top; border: 1px solid #ddd; padding: 0.5rem; border-radius: 8px; background: transparent;">
                                        <label for="${fieldName}" style="font-size: 0.8rem; font-weight: bold; margin-bottom: 0.3rem; display: block;">${attr.key}</label>
                                        <select name="${fieldName}" id="${fieldName}" class="form-control" multiple ${isRequired} style="width: 100%; padding: 0.3rem; font-size: 0.8rem; min-height: 60px;">
                                            ${attr.values.map(value => `<option value="${value}">${value}</option>`).join('')}
                                        </select>
                                    </div>
                                `;
                            }
                        });
                        
                        variantAttributesForm.innerHTML = attributesHTML;
                    }
                }
            }
            
            // Update the variant attributes grid for selection
            const variantAttributesGrid = document.getElementById('variantAttributesGrid');
            console.log('ğŸ”§ variantAttributesGrid element:', variantAttributesGrid);
            if (variantAttributesGrid) {
                if (variantAttributes.length === 0) {
                    console.log('âŒ No variant attributes found, showing empty message');
                    variantAttributesGrid.innerHTML = `
                        <div style="color: var(--text-secondary); text-align: center; padding: 2rem;">
                            <p>Ø¨Ø±Ø§ÛŒ Ø§ÛŒÙ† Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ù…Ù†Ø§Ø³Ø¨ Ø¨Ø±Ø§ÛŒ ØªÙ†ÙˆØ¹ Ù…Ø­ØµÙˆÙ„ ÛŒØ§ÙØª Ù†Ø´Ø¯.</p>
                            <p>Ù„Ø·ÙØ§ Ø¯Ø± Ù¾Ù†Ù„ Ù…Ø¯ÛŒØ±ÛŒØª ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒÛŒ Ø§Ø² Ù†ÙˆØ¹ "Single Selection" ÛŒØ§ "Multiple Selection" Ø¨Ø§ Ù…Ù‚Ø§Ø¯ÛŒØ± ØªØ¹Ø±ÛŒÙ Ø´Ø¯Ù‡ Ø§Ø¶Ø§ÙÙ‡ Ú©Ù†ÛŒØ¯.</p>
                        </div>
                    `;
                } else {
                    console.log('âœ… Rendering variant attributes grid with', variantAttributes.length, 'attributes');
                    // Render attribute selection grid
                    renderAttributeSelectionGrid(variantAttributes);
                }
            } else {
                console.error('âŒ variantAttributesGrid element not found!');
            }
        };
        
        // Simple, working rendering function
        function renderAttributeSelectionGrid(attributes) {
            console.log('ğŸ¨ Rendering', attributes.length, 'attributes');
            const grid = document.getElementById('variantAttributesGrid');
            if (!grid) {
                console.error('âŒ Grid not found!');
                return;
            }
            
            // âœ¨ Preserve currently selected attributes before clearing
            const currentlySelected = [];
            grid.querySelectorAll('.variant-attribute-item.selected').forEach(item => {
                const attrKey = item.getAttribute('data-attribute');
                if (attrKey) currentlySelected.push(attrKey);
            });
            console.log('ğŸ”„ Preserving selected attributes:', currentlySelected);
            
            grid.innerHTML = '';
            
            attributes.forEach(attr => {
                const card = document.createElement('div');
                card.className = 'variant-attribute-item';
                card.setAttribute('data-attribute', attr.key);
                
                // âœ¨ Restore selected state if this attribute was previously selected
                const wasSelected = currentlySelected.includes(attr.key);
                if (wasSelected) {
                    card.classList.add('selected');
                    console.log('âœ… Restored selection for:', attr.key);
                }
                
                // VISIBLE, clickable card styles
                card.style.cssText = `
                    padding: 1.5rem;
                    border: 3px solid #dee2e6;
                    border-radius: 12px;
                    background: #f8f9fa;
                    cursor: pointer;
                    margin-bottom: 1rem;
                    transition: all 0.3s ease;
                    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                    font-size: 16px;
                    text-align: center;
                    user-select: none;
                `;
                
                // Click handler with hover effects
                card.onclick = function() {
                    console.log('ğŸ–±ï¸ Card clicked:', attr.key);
                    toggleAttributeSelection(this, attr.key);
                };
                
                // Add hover effect to show it's clickable
                card.onmouseenter = function() {
                    if (!this.classList.contains('selected')) {
                        this.style.backgroundColor = '#e9ecef';
                        this.style.borderColor = '#007bff';
                        this.style.transform = 'scale(1.02)';
                    }
                };
                
                card.onmouseleave = function() {
                    if (!this.classList.contains('selected')) {
                        this.style.backgroundColor = '#f8f9fa';
                        this.style.borderColor = '#dee2e6';
                        this.style.transform = 'scale(1)';
                    }
                };
                
                // Card content with distinctive radio button
                card.innerHTML = `
                    <div style="font-weight: bold; margin-bottom: 0.5rem;">${attr.key}</div>
                    <div style="font-size: 0.9rem; color: #6c757d; margin-bottom: 0.75rem;">${attr.values.join(' â€¢ ')}</div>
                    <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #dee2e6;">
                        <label style="display: flex; align-items: center; justify-content: center; gap: 0.5rem; cursor: pointer; font-size: 0.9rem;">
                            <input type="radio" 
                                   name="distinctive_attribute" 
                                   value="${attr.key}" 
                                   class="distinctive-radio"
                                   style="width: 18px; height: 18px; cursor: pointer;"
                                   onclick="event.stopPropagation(); handleDistinctiveSelection('${attr.key}');">
                            <span>ÙˆÛŒÚ˜Ú¯ÛŒ Ù…ØªÙ…Ø§ÛŒØ²</span>
                        </label>
                    </div>
                `;
                
                // âœ¨ Apply selected styling if this attribute was previously selected
                if (wasSelected) {
                    card.style.backgroundColor = '#28a745';  // Strong green background
                    card.style.borderColor = '#1e7e34';      // Dark green border
                    card.style.color = 'white';              // White text
                    card.style.fontWeight = 'bold';          // Bold text
                    card.style.transform = 'scale(1.05)';    // Make it bigger
                    console.log('ğŸ¨ Applied selected styling to:', attr.key);
                }
                
                grid.appendChild(card);
                console.log(`âœ… Created card for ${attr.key}`);
            });
            
            console.log('âœ… Grid rendered successfully');
        }
        
        // Function to clear field error styling
        function clearFieldError(field) {
            field.style.borderColor = '';
            field.style.backgroundColor = '';
        }
        
        // Function to add error styling to field
        function addFieldError(field) {
            field.style.borderColor = 'red';
            field.style.backgroundColor = '#ffe6e6';
        }
        
        // Initialize category attributes data
        document.addEventListener('DOMContentLoaded', function() {
            // Parse category attributes data from the script tag
            const categoryAttributesScript = document.getElementById('category-attributes-data');
            if (categoryAttributesScript) {
                try {
                    const rawData = categoryAttributesScript.textContent;
                    console.log('ğŸ” Raw category attributes data:', rawData);
                    window.categoryAttributes = JSON.parse(rawData);
                    console.log('âœ… Category attributes loaded:', window.categoryAttributes);
                    console.log('ğŸ” Category attributes keys:', Object.keys(window.categoryAttributes));
                } catch (e) {
                    console.error('âŒ ERROR parsing category attributes:', e);
                    console.error('âŒ Raw data that failed to parse:', categoryAttributesScript.textContent);
                    window.categoryAttributes = {};
                }
            } else {
                console.error('âŒ ERROR: Category attributes script tag not found!');
                window.categoryAttributes = {};
            }
            
            // Parse existing attributes data from the script tag
            const existingAttrsScript = document.getElementById('existing-attrs-data');
            if (existingAttrsScript) {
                try {
                    window.existingAttrs = JSON.parse(existingAttrsScript.textContent);
                    console.log('âœ… Existing attributes loaded:', window.existingAttrs);
                } catch (e) {
                    console.error('âŒ Error parsing existing attributes:', e);
                    window.existingAttrs = {};
                }
            } else {
                console.error('âŒ Existing attributes script tag not found');
                window.existingAttrs = {};
            }
            
            // Parse existing variants data from the script tag
            const existingVariantsScript = document.getElementById('existing-variants-data');
            console.log('ğŸ” DEBUG: existingVariantsScript element:', existingVariantsScript);
            if (existingVariantsScript) {
                console.log('ğŸ” DEBUG: Script tag found, textContent length:', existingVariantsScript.textContent.length);
                console.log('ğŸ” DEBUG: Raw textContent:', existingVariantsScript.textContent);
                try {
                    window.existingVariants = JSON.parse(existingVariantsScript.textContent);
                    console.log('âœ… Existing variants loaded:', window.existingVariants);
                    console.log('ğŸ” DEBUG: Raw existing variants data:', existingVariantsScript.textContent);
                    console.log('ğŸ” DEBUG: Parsed variants count:', window.existingVariants.length);
                    
                    // âœ¨ CRITICAL: Load existing variant images into variantState
                    console.log('ğŸ–¼ï¸ Loading existing variant images into variantState...');
                    console.log('ğŸ” DEBUG: variantState before loading:', variantState);
                    console.log('ğŸ” DEBUG: variantState.variantImages before loading:', variantState.variantImages);
                    
                    if (window.existingVariants && window.existingVariants.length > 0) {
                        window.existingVariants.forEach((variant, index) => {
                            console.log(`ğŸ” DEBUG: Processing variant ${index + 1}:`, {
                                sku: variant.sku,
                                id: variant.id,
                                hasImages: !!(variant.images),
                                imageCount: variant.images ? variant.images.length : 0,
                                firstImagePreview: variant.images && variant.images[0] ? variant.images[0].substring(0, 100) + '...' : 'No images'
                            });
                            
                            if (variant.images && variant.images.length > 0) {
                                variantState.variantImages[variant.sku] = variant.images;
                                console.log(`âœ… Loaded ${variant.images.length} images for variant ${variant.sku}`);
                                console.log(`ğŸ” DEBUG: Stored images for ${variant.sku}:`, variant.images.map(img => img.substring(0, 50) + '...'));
                            } else {
                                console.log(`âš ï¸ No images found for variant ${variant.sku}`);
                            }
                        });
                        console.log('âœ… Variant images loaded into variantState:', variantState.variantImages);
                        console.log('ğŸ” DEBUG: Final variantState.variantImages keys:', Object.keys(variantState.variantImages));
                    } else {
                        console.log('âš ï¸ No existing variants found to process');
                    }
                    
                    // Load existing variants into the table
                    if (window.existingVariants && window.existingVariants.length > 0) {
                        // Add a small delay to ensure DOM is fully ready
                        setTimeout(() => {
                            loadExistingVariants();
                        }, 100);
                    }
                } catch (e) {
                    console.error('âŒ Error parsing existing variants:', e);
                    console.error('âŒ Raw content that failed to parse:', existingVariantsScript.textContent);
                    window.existingVariants = [];
                }
            } else {
                console.error('âŒ Existing variants script tag not found');
                console.log('ğŸ” DEBUG: Looking for script tag with ID "existing-variants-data"');
                console.log('ğŸ” DEBUG: All script tags:', document.querySelectorAll('script'));
                window.existingVariants = [];
            }
            
            // Add event listeners to clear error styling when fields are filled
            const form = document.getElementById('product_form');
            if (form) {
                const allInputs = form.querySelectorAll('input, select, textarea');
                allInputs.forEach(input => {
                    input.addEventListener('input', function() {
                        if (this.value.trim()) {
                            clearFieldError(this);
                        }
                    });
                    input.addEventListener('change', function() {
                        if (this.value.trim()) {
                            clearFieldError(this);
                        }
                    });
                });
            }
            
            // Function to edit a variant from the table
            function editVariantFromTable(button) {
                console.log('ğŸ”§ editVariantFromTable called');
                console.log('ğŸ” DEBUG: Button element:', button);
                console.log('ğŸ” DEBUG: Button onclick attribute:', button.getAttribute('onclick'));
                console.log('ğŸ” DEBUG: Function is executing - this should appear in logs');
                
                // Prevent any form submission
                if (typeof event !== 'undefined' && event) {
                    event.preventDefault();
                    event.stopPropagation();
                }
                
                const row = button.closest('tr');
                const cells = row.querySelectorAll('td');
                
                console.log('ğŸ” DEBUG: Row element:', row);
                console.log('ğŸ” DEBUG: Number of cells found:', cells.length);
                console.log('ğŸ” DEBUG: Cells:', Array.from(cells).map((cell, index) => ({
                    index,
                    textContent: cell.textContent.trim(),
                    innerHTML: cell.innerHTML
                })));
                
                if (cells.length < 6) {
                    console.error('âŒ Invalid table row structure - expected 6 cells, found:', cells.length);
                    console.log('ğŸ” DEBUG: Function will return early due to table structure');
                    return;
                }
                
                console.log('ğŸ” DEBUG: Table structure is OK, continuing with data extraction');
                
                // Extract data from table row
                const sku = cells[0].textContent.trim();
                const attributesText = cells[1].textContent.trim();
                const priceText = cells[2].textContent.trim();
                const stockText = cells[3].textContent.trim();
                const statusText = cells[4].textContent.trim();
                
                console.log('ğŸ” DEBUG: Raw cell data:', {
                    sku,
                    attributesText,
                    priceText,
                    stockText,
                    statusText
                });
                
                // Parse attributes
                let parsedAttributes = {};
                console.log('ğŸ” DEBUG: attributesText from table:', attributesText);
                console.log('ğŸ” DEBUG: attributesText length:', attributesText.length);
                console.log('ğŸ” DEBUG: attributesText is not empty:', !!(attributesText && attributesText !== '-'));
                
                if (attributesText && attributesText !== '-') {
                    console.log('ğŸ” DEBUG: Starting attribute parsing...');
                    // Handle HTML content in attributes text (from badges)
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = attributesText;
                    const textContent = tempDiv.textContent || tempDiv.innerText || '';
                    console.log('ğŸ” DEBUG: Extracted text content from HTML:', textContent);
                    
                    // Parse attributes from the text content
                    const attrPairs = textContent.split(/\s+/);
                    console.log('ğŸ” DEBUG: Split attribute pairs:', attrPairs);
                    attrPairs.forEach(pair => {
                        if (pair.includes(':')) {
                            const colonIndex = pair.indexOf(':');
                            const key = pair.substring(0, colonIndex).trim();
                            const value = pair.substring(colonIndex + 1).trim();
                            if (key && value) {
                                parsedAttributes[key] = value;
                                console.log(`ğŸ” DEBUG: Parsed attribute: ${key} = ${value}`);
                            }
                        }
                    });
                } else {
                    console.log('ğŸ” DEBUG: No attributes text to parse or empty');
                    console.log('ğŸ” DEBUG: This is why parsedAttributes is empty!');
                }
                console.log('ğŸ” DEBUG: Final parsed attributes object:', parsedAttributes);
                console.log('ğŸ” DEBUG: parsedAttributes keys:', Object.keys(parsedAttributes));
                
                // Parse price
                const price = priceText.replace(/[,\sØªÙˆÙ…Ø§Ù†]/g, '') || '0';
                
                // Parse stock
                const stock = parseInt(stockText) || 0;
                
                // Parse status
                const isActive = statusText.includes('ÙØ¹Ø§Ù„');
                const isDefault = statusText.includes('Ù¾ÛŒØ´â€ŒÙØ±Ø¶');
                
                console.log('ğŸ”§ Extracted variant data:', { sku, attributes: parsedAttributes, price, stock, isActive, isDefault });
                
                // Open modal and populate form
                const modal = document.getElementById('variantModal');
                const title = document.getElementById('variantModalTitle');
                const form = document.getElementById('variantForm');
                
                if (!modal || !form) {
                    console.error('âŒ Modal or form not found');
                    return;
                }
                
                // Update modal title
                if (title) {
                    title.textContent = 'ÙˆÛŒØ±Ø§ÛŒØ´ Ù†ÙˆØ¹ Ù…Ø­ØµÙˆÙ„';
                }
                
                // Populate form fields
                const skuInput = document.getElementById('variantSku');
                const priceInput = document.getElementById('variantPriceToman');
                const stockInput = document.getElementById('variantStock');
                const activeCheckbox = document.getElementById('variantIsActive');
                const defaultCheckbox = document.getElementById('variantIsDefault');
                
                if (skuInput) skuInput.value = sku;
                if (priceInput) priceInput.value = price;
                if (stockInput) stockInput.value = stock;
                if (activeCheckbox) activeCheckbox.checked = isActive;
                if (defaultCheckbox) defaultCheckbox.checked = isDefault;
                
                // Set edit mode by setting variantIndex
                const variantIndexInput = document.getElementById('variantIndex');
                if (variantIndexInput) {
                    // Find the index of this variant in the existing variants array
                    console.log('ğŸ” DEBUG: Looking for variant with SKU:', sku);
                    console.log('ğŸ” DEBUG: window.existingVariants:', window.existingVariants);
                    console.log('ğŸ” DEBUG: Available SKUs in existingVariants:', window.existingVariants.map(v => v.sku));
                    
                    const variantIndex = window.existingVariants.findIndex(v => v.sku === sku);
                    console.log('ğŸ”§ Set variantIndex to:', variantIndex);
                    
                    if (variantIndex === -1) {
                        console.error('âŒ Variant not found in window.existingVariants with SKU:', sku);
                        console.log('ğŸ” DEBUG: This means the variant data is not properly loaded or SKU mismatch');
                    } else {
                        console.log('âœ… Found variant at index:', variantIndex);
                        console.log('ğŸ” DEBUG: Found variant data:', window.existingVariants[variantIndex]);
                    }
                    
                    variantIndexInput.value = variantIndex >= 0 ? variantIndex : '';
                }
                
                // Store row reference for updating after save
                form.dataset.editingRow = 'true';
                form.dataset.rowElement = row.outerHTML;
                
                // Show modal
                modal.style.display = 'block';
                console.log('âœ… Variant edit modal opened from table');
                console.log('ğŸ” DEBUG: parsedAttributes available in modal scope:', parsedAttributes);
                console.log('ğŸ” DEBUG: parsedAttributes keys in modal scope:', Object.keys(parsedAttributes));
                
                // âœ¨ CRITICAL: Manually populate the form fields with the parsed attributes
                console.log('ğŸ” DEBUG: Manually populating form fields...');
                if (parsedAttributes && Object.keys(parsedAttributes).length > 0) {
                    Object.keys(parsedAttributes).forEach(key => {
                        // Try both ID formats: variant_attr_${key} and attr_${key}
                        const input = document.getElementById(`variant_attr_${key}`) || document.getElementById(`attr_${key}`);
                        if (input) {
                            input.value = parsedAttributes[key];
                            console.log(`âœ… Manually populated ${key} with value: ${parsedAttributes[key]}`);
                        } else {
                            console.log(`âŒ Could not find input for attribute: ${key}`);
                            console.log(`ğŸ” DEBUG: Tried IDs: variant_attr_${key} and attr_${key}`);
                        }
                    });
                } else {
                    console.log('âš ï¸ No parsedAttributes to populate manually');
                }
                
                // âœ¨ CRITICAL: Load images from variantState.variantImages
                console.log('ğŸ–¼ï¸ Loading variant images from variantState...');
                console.log('ğŸ” DEBUG: variantState.variantImages:', variantState.variantImages);
                console.log('ğŸ” DEBUG: Looking for images with SKU:', sku);
                
                const variantImages = variantState.variantImages[sku] || [];
                console.log(`ğŸ” Found ${variantImages.length} images for variant ${sku}`);
                
                if (variantImages.length > 0) {
                    // Clear existing previews first
                    const previewContainer = document.getElementById('variantImagePreviews');
                    if (previewContainer) {
                        previewContainer.innerHTML = '';
                        console.log('ğŸ§¹ Cleared existing image previews');
                    }
                    
                    // Add each image to the preview container
                    variantImages.forEach((imageData, index) => {
                        if (previewContainer) {
                            const previewDiv = document.createElement('div');
                            previewDiv.className = 'preview-item';
                            previewDiv.style.cssText = `
                                display: flex;
                                flex-direction: column;
                                position: relative;
                                border-radius: 8px;
                                overflow: hidden;
                                box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                                cursor: move;
                                transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                                user-select: none;
                            `;

                            const img = document.createElement('img');
                            img.src = imageData;
                            img.style.cssText = `
                                display: block;
                                width: 150px;
                                height: 150px;
                                object-fit: cover;
                                pointer-events: none;
                            `;

                            // Order label
                            const label = document.createElement('div');
                            label.textContent = `${index + 1}`;
                            label.style.cssText = `
                                position: absolute;
                                top: 8px;
                                right: 8px;
                                background: rgba(0,0,0,0.7);
                                color: white;
                                padding: 4px 8px;
                                border-radius: 12px;
                                font-size: 12px;
                                font-weight: bold;
                            `;

                            // Remove button
                            const removeBtn = document.createElement('button');
                            removeBtn.innerHTML = 'Ã—';
                            removeBtn.style.cssText = `
                                position: absolute;
                                top: 8px;
                                left: 8px;
                                background: rgba(255,0,0,0.8);
                                color: white;
                                border: none;
                                border-radius: 50%;
                                width: 24px;
                                height: 24px;
                                cursor: pointer;
                                font-size: 16px;
                                font-weight: bold;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                            `;
                            removeBtn.onclick = function() {
                                previewDiv.remove();
                                // Remove from stored images
                                if (variantState.variantImages[variant.sku]) {
                                    variantState.variantImages[variant.sku].splice(index, 1);
                                    console.log(`ğŸ—‘ï¸ Removed image ${index + 1} from variant ${variant.sku}`);
                                }
                            };

                            previewDiv.appendChild(img);
                            previewDiv.appendChild(label);
                            previewDiv.appendChild(removeBtn);
                            previewContainer.appendChild(previewDiv);
                            
                            console.log(`âœ… Loaded image ${index + 1} for variant ${sku}`);
                        }
                    });
                    console.log(`âœ… Loaded ${variantImages.length} images for editing`);
                } else {
                    console.log('â„¹ï¸ No images found for this variant');
                }
                
                // âœ¨ CRITICAL: Force load category attributes to ensure variant attributes form is populated
                console.log('ğŸ”„ Force loading category attributes for variant editing...');
                const categorySelect = document.getElementById('id_category');
                if (categorySelect && categorySelect.value && typeof window.loadCategoryAttributes === 'function') {
                    console.log('ğŸ” Loading category attributes for category:', categorySelect.value);
                    window.loadCategoryAttributes(categorySelect.value);
                    
                    // After loading category attributes, update variant attributes form
                    setTimeout(() => {
                        console.log('ğŸ”„ Updating variant attributes form after category load...');
                        updateVariantAttributesForm();
                        
                        // Then populate the attributes
                        setTimeout(() => {
                            console.log('ğŸ”„ Populating variant attributes after form update...');
                            console.log('ğŸ” DEBUG: parsedAttributes object to populate:', parsedAttributes);
                            console.log('ğŸ” DEBUG: parsedAttributes type:', typeof parsedAttributes);
                            console.log('ğŸ” DEBUG: parsedAttributes keys:', Object.keys(parsedAttributes));
                            
                            if (parsedAttributes && typeof parsedAttributes === 'object' && Object.keys(parsedAttributes).length > 0) {
                                console.log('ğŸ” DEBUG: Processing parsedAttributes object with keys:', Object.keys(parsedAttributes));
                                Object.keys(parsedAttributes).forEach(key => {
                                    // Try both ID formats: variant_attr_${key} and attr_${key}
                                    const input = document.getElementById(`variant_attr_${key}`) || document.getElementById(`attr_${key}`);
                                    console.log(`ğŸ” DEBUG: Looking for input with IDs: variant_attr_${key} and attr_${key}`);
                                    console.log(`ğŸ” DEBUG: Found input element:`, input);
                                    if (input) {
                                        input.value = parsedAttributes[key];
                                        console.log(`âœ… Populated attribute ${key} with value: ${parsedAttributes[key]}`);
                                    } else {
                                        console.log(`âŒ Could not find input for attribute: ${key}`);
                                        console.log(`ğŸ” DEBUG: Available inputs in form:`, Array.from(document.querySelectorAll('input[id^="attr_"], select[id^="attr_"], input[id^="variant_attr_"], select[id^="variant_attr_"]')).map(el => el.id));
                                    }
                                });
                            } else {
                                console.log('âš ï¸ No parsedAttributes object found or invalid type or empty');
                                console.log('ğŸ” DEBUG: parsedAttributes value:', parsedAttributes);
                                console.log('ğŸ” DEBUG: parsedAttributes keys length:', parsedAttributes ? Object.keys(parsedAttributes).length : 'N/A');
                                
                                // âœ¨ FALLBACK: Try to populate from the table row directly
                                console.log('ğŸ” DEBUG: Trying fallback population from table row...');
                                const currentRow = button.closest('tr');
                                if (currentRow) {
                                    const cells = currentRow.querySelectorAll('td');
                                    if (cells.length >= 2) {
                                        const attributesText = cells[1].textContent.trim();
                                        console.log('ğŸ” DEBUG: Fallback attributesText:', attributesText);
                                        
                                        if (attributesText && attributesText !== '-') {
                                            const tempDiv = document.createElement('div');
                                            tempDiv.innerHTML = attributesText;
                                            const textContent = tempDiv.textContent || tempDiv.innerText || '';
                                            console.log('ğŸ” DEBUG: Fallback textContent:', textContent);
                                            
                                            // Parse attributes from the text content - handle "key: value" format
                                            console.log('ğŸ” DEBUG: Fallback textContent to parse:', textContent);
                                            
                                            // Use regex to find all "key: value" patterns
                                            const attributeRegex = /(\w+):\s*([^\s]+)/g;
                                            let match;
                                            
                                            while ((match = attributeRegex.exec(textContent)) !== null) {
                                                const key = match[1].trim();
                                                const value = match[2].trim();
                                                console.log(`ğŸ” DEBUG: Fallback regex extracted key: "${key}", value: "${value}"`);
                                                
                                                if (key && value) {
                                                    // Try both ID formats: variant_attr_${key} and attr_${key}
                                                    const input = document.getElementById(`variant_attr_${key}`) || document.getElementById(`attr_${key}`);
                                                    console.log(`ğŸ” DEBUG: Fallback looking for input with IDs: variant_attr_${key} and attr_${key}`);
                                                    console.log(`ğŸ” DEBUG: Fallback found input element:`, input);
                                                    if (input) {
                                                        input.value = value;
                                                        console.log(`âœ… Fallback populated ${key} with value: ${value}`);
                                                        console.log(`ğŸ” DEBUG: Fallback input.value after setting:`, input.value);
                                                    } else {
                                                        console.log(`âŒ Fallback could not find input for attribute: ${key}`);
                                                        console.log(`ğŸ” DEBUG: Fallback available inputs:`, Array.from(document.querySelectorAll('input[id^="attr_"], select[id^="attr_"], input[id^="variant_attr_"], select[id^="variant_attr_"]')).map(el => el.id));
                                                    }
                                                } else {
                                                    console.log(`âš ï¸ Fallback skipped due to empty key or value`);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }, 200);
                    }, 200);
                } else {
                    console.log('âŒ Cannot load category attributes - categorySelect or loadCategoryAttributes function not found');
                }
            }
            
            // Function to edit an existing variant
            function editVariant(variantId) {
                console.log('ğŸ”§ editVariant called with variantId:', variantId);
                console.log('ğŸ” DEBUG: window.existingVariants:', window.existingVariants);
                console.log('ğŸ” DEBUG: Looking for variant with ID:', variantId);
                console.log('ğŸ” DEBUG: All variant IDs available:', window.existingVariants.map(v => v.id));
                
                // Prevent any form submission
                if (typeof event !== 'undefined' && event) {
                    event.preventDefault();
                    event.stopPropagation();
                }
                
                // Find variant by ID (support both string and numeric IDs)
                const variant = window.existingVariants.find(v => v.id == variantId || v.id === variantId);
                console.log('ğŸ” DEBUG: Found variant:', variant);
                console.log('ğŸ” DEBUG: Variant attributes:', variant ? variant.attributes : 'No variant found');
                console.log('ğŸ” DEBUG: Variant attributes type:', variant ? typeof variant.attributes : 'No variant found');
                console.log('ğŸ” DEBUG: Variant attributes keys:', variant && variant.attributes ? Object.keys(variant.attributes) : 'No variant found');
                
                if (!variant) {
                    console.error('âŒ Variant not found with ID:', variantId);
                    console.error('âŒ Available variants:', window.existingVariants.map(v => ({ id: v.id, sku: v.sku })));
                    console.log('ğŸ” DEBUG: window.existingVariants is empty, trying to load from table instead...');
                    
                    // Try to find the variant in the table and use editVariantFromTable logic
                    const tableRows = document.querySelectorAll('#variantsTableBody tr');
                    console.log('ğŸ” DEBUG: Found table rows:', tableRows.length);
                    
                    for (let row of tableRows) {
                        const editButton = row.querySelector('button[onmousedown*="editVariant"]');
                        if (editButton && editButton.getAttribute('onmousedown').includes(variantId)) {
                            console.log('ğŸ” DEBUG: Found matching table row, calling editVariantFromTable...');
                            // Create a fake button element to pass to editVariantFromTable
                            const fakeButton = { closest: () => row };
                            editVariantFromTable(fakeButton);
                            return;
                        }
                    }
                    
                    alert('Ù†ÙˆØ¹ Ù…Ø­ØµÙˆÙ„ Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯');
                    return;
                }
                
                const variantIndex = window.existingVariants.findIndex(v => v.id == variantId || v.id === variantId);
                console.log('ğŸ”§ Editing variant:', variant);
                console.log('ğŸ”§ Variant array index:', variantIndex);
                
                // Open the variant modal
                const modal = document.getElementById('variantModal');
                const title = document.getElementById('variantModalTitle');
                const form = document.getElementById('variantForm');
                const variantIndexInput = document.getElementById('variantIndex');
                
                if (!modal || !form) {
                    console.error('âŒ Variant modal or form not found');
                    alert('ÙØ±Ù… ÙˆÛŒØ±Ø§ÛŒØ´ Ù†ÙˆØ¹ Ù…Ø­ØµÙˆÙ„ ÛŒØ§ÙØª Ù†Ø´Ø¯');
                    return;
                }
                
                // Update modal title
                if (title) {
                    title.textContent = 'ÙˆÛŒØ±Ø§ÛŒØ´ Ù†ÙˆØ¹ Ù…Ø­ØµÙˆÙ„';
                }
                
                // Set the variant index for saving
                if (variantIndexInput) {
                    variantIndexInput.value = variantIndex;
                    console.log('ğŸ”§ DEBUG: Set variantIndex input value to:', variantIndex);
                    console.log('ğŸ”§ DEBUG: variantIndexInput.value is now:', variantIndexInput.value);
                } else {
                    console.error('âŒ variantIndexInput not found!');
                }
                
                // Set global editing flag
                window.isEditingVariant = true;
                window.editingVariantId = variantId;
                console.log('ğŸ”§ DEBUG: Set global editing flags - isEditingVariant:', window.isEditingVariant, 'editingVariantId:', window.editingVariantId);
                
                // Populate form fields with existing variant data
                const skuInput = document.getElementById('variantSku');
                const priceInput = document.getElementById('variantPriceToman');
                const stockInput = document.getElementById('variantStock');
                const activeCheckbox = document.getElementById('variantIsActive');
                const defaultCheckbox = document.getElementById('variantIsDefault');
                
                if (skuInput) skuInput.value = variant.sku || '';
                if (priceInput) priceInput.value = variant.price_toman || '';
                if (stockInput) stockInput.value = variant.stock_quantity || '';
                if (activeCheckbox) activeCheckbox.checked = variant.is_active || false;
                if (defaultCheckbox) defaultCheckbox.checked = variant.is_default || false;
                
                // Update the variant attributes form before populating values
                console.log('ğŸ” DEBUG: About to call updateVariantAttributesForm()...');
                console.log('ğŸ” DEBUG: Current category ID:', document.getElementById('id_category')?.value);
                console.log('ğŸ” DEBUG: window.categoryAttributes:', window.categoryAttributes);
                updateVariantAttributesForm();
                console.log('ğŸ” DEBUG: updateVariantAttributesForm() completed');
                
                // âœ¨ CRITICAL: Populate variant attributes with existing values (with delay to ensure form is created)
                setTimeout(() => {
                    console.log('ğŸ” DEBUG: About to populate variant attributes with existing values...');
                    console.log('ğŸ” DEBUG: Variant attributes to populate:', variant.attributes);
                    if (variant.attributes && typeof variant.attributes === 'object' && Object.keys(variant.attributes).length > 0) {
                        console.log('ğŸ” DEBUG: Processing variant attributes for population...');
                        Object.keys(variant.attributes).forEach(key => {
                            const value = variant.attributes[key];
                            console.log(`ğŸ” DEBUG: Processing attribute ${key} = ${value}`);
                            
                            // Try both ID formats: variant_attr_${key} and attr_${key}
                            const input = document.getElementById(`variant_attr_${key}`) || document.getElementById(`attr_${key}`);
                            console.log(`ğŸ” DEBUG: Looking for input with IDs: variant_attr_${key} and attr_${key}`);
                            console.log(`ğŸ” DEBUG: Found input element:`, input);
                            
                            if (input) {
                                input.value = value;
                                console.log(`âœ… Populated attribute ${key} with value: ${value}`);
                            } else {
                                console.log(`âŒ Could not find input for attribute: ${key}`);
                                console.log(`ğŸ” DEBUG: Available inputs in form:`, Array.from(document.querySelectorAll('input[id^="attr_"], select[id^="attr_"], input[id^="variant_attr_"], select[id^="variant_attr_"]')).map(el => el.id));
                            }
                        });
                    } else {
                        console.log('âš ï¸ No variant attributes to populate or invalid format');
                        console.log('ğŸ” DEBUG: variant.attributes value:', variant.attributes);
                        console.log('ğŸ” DEBUG: variant.attributes type:', typeof variant.attributes);
                    }
                }, 500);
                
                // âœ¨ CRITICAL: Populate variant attributes with existing values
                console.log('ğŸ” DEBUG: About to populate variant attributes with existing values...');
                console.log('ğŸ” DEBUG: Variant attributes to populate:', variant.attributes);
                if (variant.attributes && typeof variant.attributes === 'object') {
                    console.log('ğŸ” DEBUG: Processing variant attributes for population...');
                    Object.keys(variant.attributes).forEach(key => {
                        const value = variant.attributes[key];
                        console.log(`ğŸ” DEBUG: Processing attribute ${key} = ${value}`);
                        
                        // Try both ID formats: variant_attr_${key} and attr_${key}
                        const input = document.getElementById(`variant_attr_${key}`) || document.getElementById(`attr_${key}`);
                        console.log(`ğŸ” DEBUG: Looking for input with IDs: variant_attr_${key} and attr_${key}`);
                        console.log(`ğŸ” DEBUG: Found input element:`, input);
                        
                        if (input) {
                            input.value = value;
                            console.log(`âœ… Populated attribute ${key} with value: ${value}`);
                        } else {
                            console.log(`âŒ Could not find input for attribute: ${key}`);
                            console.log(`ğŸ” DEBUG: Available inputs in form:`, Array.from(document.querySelectorAll('input[id^="attr_"], select[id^="attr_"], input[id^="variant_attr_"], select[id^="variant_attr_"]')).map(el => el.id));
                        }
                    });
                } else {
                    console.log('âš ï¸ No variant attributes to populate or invalid format');
                    console.log('ğŸ” DEBUG: variant.attributes value:', variant.attributes);
                    console.log('ğŸ” DEBUG: variant.attributes type:', typeof variant.attributes);
                }
                
                // âœ¨ CRITICAL: Load existing variant images for editing
                console.log('ğŸ–¼ï¸ Loading existing variant images for editing...');
                console.log('ğŸ” DEBUG: variantState.variantImages:', variantState.variantImages);
                console.log('ğŸ” DEBUG: Looking for images with key:', variant.sku);
                console.log('ğŸ” DEBUG: Available keys in variantState.variantImages:', Object.keys(variantState.variantImages));
                
                const tableVariantImages = variantState.variantImages[variant.sku] || [];
                console.log(`ğŸ” Found ${tableVariantImages.length} stored images for variant ${variant.sku}`);
                console.log('ğŸ” DEBUG: tableVariantImages content:', tableVariantImages);
                
                if (tableVariantImages.length > 0) {
                    console.log('ğŸ” DEBUG: First image preview:', tableVariantImages[0].substring(0, 100) + '...');
                } else {
                    console.log('âš ï¸ No images found in variantState.variantImages for this variant');
                    console.log('ğŸ” DEBUG: Checking if variant has images property:', variant.images);
                    if (variant.images && variant.images.length > 0) {
                        console.log('ğŸ” DEBUG: Variant has images property with', variant.images.length, 'images');
                        console.log('ğŸ” DEBUG: First variant image:', variant.images[0].substring(0, 100) + '...');
                        // Try to load from variant.images directly
                        variantState.variantImages[variant.sku] = variant.images;
                        console.log('âœ… Loaded images from variant.images property');
                    }
                }
                
                if (tableVariantImages.length > 0) {
                    // Clear existing previews first
                    const previewContainer = document.getElementById('variantImagePreviews');
                    if (previewContainer) {
                        previewContainer.innerHTML = '';
                        console.log('ğŸ§¹ Cleared existing image previews');
                    }
                    
                    // Add each stored image to the preview container
                    tableVariantImages.forEach((imageData, index) => {
                        if (previewContainer) {
                            const previewDiv = document.createElement('div');
                            previewDiv.className = 'preview-item';
                            previewDiv.style.cssText = `
                                display: flex;
                                flex-direction: column;
                                position: relative;
                                border-radius: 8px;
                                overflow: hidden;
                                box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                                cursor: move;
                                transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                                user-select: none;
                            `;

                            const img = document.createElement('img');
                            img.src = imageData;
                            img.style.cssText = `
                                display: block;
                                width: 150px;
                                height: 150px;
                                object-fit: cover;
                                pointer-events: none;
                            `;

                            // Order label
                            const label = document.createElement('div');
                            label.textContent = `${index + 1}`;
                            label.style.cssText = `
                                position: absolute;
                                top: 8px;
                                right: 8px;
                                background: rgba(0,0,0,0.7);
                                color: white;
                                padding: 4px 8px;
                                border-radius: 12px;
                                font-size: 12px;
                                font-weight: bold;
                            `;

                            // Remove button
                            const removeBtn = document.createElement('button');
                            removeBtn.innerHTML = 'Ã—';
                            removeBtn.style.cssText = `
                                position: absolute;
                                top: 8px;
                                left: 8px;
                                background: rgba(255,0,0,0.8);
                                color: white;
                                border: none;
                                border-radius: 50%;
                                width: 24px;
                                height: 24px;
                                cursor: pointer;
                                font-size: 16px;
                                font-weight: bold;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                            `;
                            removeBtn.onclick = function() {
                                previewDiv.remove();
                                // Remove from stored images
                                if (variantState.variantImages[variant.sku]) {
                                    variantState.variantImages[variant.sku].splice(index, 1);
                                    console.log(`ğŸ—‘ï¸ Removed image ${index + 1} from variant ${variant.sku}`);
                                }
                            };

                            previewDiv.appendChild(img);
                            previewDiv.appendChild(label);
                            previewDiv.appendChild(removeBtn);
                            previewContainer.appendChild(previewDiv);
                            
                            console.log(`âœ… Loaded existing image ${index + 1} for variant ${variant.sku}`);
                        }
                    });
                    console.log(`âœ… Loaded ${tableVariantImages.length} existing images for editing`);
                } else {
                    console.log('â„¹ï¸ No existing images found for this variant');
                }
                
                // Populate variant attributes after a short delay to ensure form is updated
                console.log('ğŸ” DEBUG: About to populate variant attributes...');
                console.log('ğŸ” DEBUG: attributes object:', variant.attributes);
                console.log('ğŸ” DEBUG: typeof attributes:', typeof variant.attributes);
                
                setTimeout(() => {
                    if (variant.attributes && typeof variant.attributes === 'object') {
                        console.log('ğŸ” DEBUG: Processing attributes object with keys:', Object.keys(variant.attributes));
                        Object.keys(variant.attributes).forEach(key => {
                            // Try both possible input IDs: variant_attr_${key} and attr_${key}
                            let input = document.getElementById(`variant_attr_${key}`);
                            console.log(`ğŸ” DEBUG: Looking for input with ID: variant_attr_${key}`);
                            console.log(`ğŸ” DEBUG: Found input element:`, input);
                            
                            if (!input) {
                                // Fallback to attr_${key} for backward compatibility
                                input = document.getElementById(`attr_${key}`);
                                console.log(`ğŸ” DEBUG: Fallback - looking for input with ID: attr_${key}`);
                                console.log(`ğŸ” DEBUG: Found fallback input element:`, input);
                            }
                            
                            if (input) {
                                // Handle different input types
                                if (input.type === 'select-multiple' || (input.tagName === 'SELECT' && input.multiple)) {
                                    // For multiselect fields, split the value and select multiple options
                                    const values = variant.attributes[key].split(',').map(v => v.trim());
                                    console.log(`ğŸ” DEBUG: Setting multiselect values for ${key}:`, values);
                                    
                                    // Clear existing selections
                                    Array.from(input.options).forEach(option => option.selected = false);
                                    
                                    // Select matching options
                                    values.forEach(value => {
                                        const option = Array.from(input.options).find(opt => opt.value === value);
                                        if (option) {
                                            option.selected = true;
                                            console.log(`âœ… Selected option: ${value}`);
                                        } else {
                                            console.log(`âŒ Option not found: ${value}`);
                                        }
                                    });
                                } else {
                                    // For single-select and text inputs
                                    input.value = variant.attributes[key];
                                }
                                console.log(`âœ… Populated attribute ${key} with value: ${variant.attributes[key]}`);
                            } else {
                                console.log(`âŒ Could not find input for attribute: ${key}`);
                                console.log(`ğŸ” DEBUG: Available inputs in form:`, Array.from(document.querySelectorAll('input[id*="${key}"], select[id*="${key}"]')).map(el => el.id));
                            }
                        });
                    } else {
                        console.log('âš ï¸ No attributes object found or invalid type');
                        console.log('ğŸ” DEBUG: attributes value:', variant.attributes);
                    }
                }, 100);
                
                // âœ¨ CRITICAL: Load existing variant images
                console.log('ğŸ–¼ï¸ Loading existing variant images for editing...');
                console.log('ğŸ” DEBUG: variantState.variantImages:', variantState.variantImages);
                console.log('ğŸ” DEBUG: Looking for images with key:', variant.sku);
                console.log('ğŸ” DEBUG: Available keys in variantState.variantImages:', Object.keys(variantState.variantImages));
                
                const existingVariantImages = variantState.variantImages[variant.sku] || [];
                console.log(`ğŸ” Found ${existingVariantImages.length} stored images for variant ${variant.sku}`);
                console.log('ğŸ” DEBUG: existingVariantImages content:', existingVariantImages);
                
                if (existingVariantImages.length > 0) {
                    console.log('ğŸ” DEBUG: First image preview:', existingVariantImages[0].substring(0, 100) + '...');
                } else {
                    console.log('âš ï¸ No images found in variantState.variantImages for this variant');
                    console.log('ğŸ” DEBUG: Checking if variant has images property:', variant.images);
                    if (variant.images && variant.images.length > 0) {
                        console.log('ğŸ” DEBUG: Variant has images property with', variant.images.length, 'images');
                        console.log('ğŸ” DEBUG: First variant image:', variant.images[0].substring(0, 100) + '...');
                        // Try to load from variant.images directly
                        variantState.variantImages[variant.sku] = variant.images;
                        console.log('âœ… Loaded images from variant.images property');
                    }
                }
                
                if (existingVariantImages.length > 0) {
                    // Clear existing previews first
                    const previewContainer = document.getElementById('variantImagePreviews');
                    if (previewContainer) {
                        previewContainer.innerHTML = '';
                        console.log('ğŸ§¹ Cleared existing image previews');
                    }
                    
                    // Add each stored image to the preview container
                    tableVariantImages.forEach((imageData, index) => {
                        if (previewContainer) {
                            const previewDiv = document.createElement('div');
                            previewDiv.className = 'preview-item';
                            previewDiv.style.cssText = `
                                display: flex;
                                flex-direction: column;
                                position: relative;
                                border-radius: 8px;
                                overflow: hidden;
                                box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                                cursor: move;
                                transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                                user-select: none;
                            `;

                            const img = document.createElement('img');
                            img.src = imageData;
                            img.style.cssText = `
                                display: block;
                                width: 150px;
                                height: 150px;
                                object-fit: cover;
                                pointer-events: none;
                            `;

                            // Order label
                            const label = document.createElement('div');
                            label.textContent = `${index + 1}`;
                            label.style.cssText = `
                                position: absolute;
                                top: 8px;
                                right: 8px;
                                background: rgba(0,0,0,0.7);
                                color: white;
                                padding: 4px 8px;
                                border-radius: 12px;
                                font-size: 12px;
                                font-weight: bold;
                            `;

                            // Remove button
                            const removeBtn = document.createElement('button');
                            removeBtn.innerHTML = 'Ã—';
                            removeBtn.style.cssText = `
                                position: absolute;
                                top: 8px;
                                left: 8px;
                                background: rgba(255,0,0,0.8);
                                color: white;
                                border: none;
                                border-radius: 50%;
                                width: 24px;
                                height: 24px;
                                cursor: pointer;
                                font-size: 16px;
                                font-weight: bold;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                            `;
                            removeBtn.onclick = function() {
                                previewDiv.remove();
                                // Remove from stored images
                                if (variantState.variantImages[variant.sku]) {
                                    variantState.variantImages[variant.sku].splice(index, 1);
                                    console.log(`ğŸ—‘ï¸ Removed image ${index + 1} from variant ${variant.sku}`);
                                }
                            };

                            previewDiv.appendChild(img);
                            previewDiv.appendChild(label);
                            previewDiv.appendChild(removeBtn);
                            previewContainer.appendChild(previewDiv);
                            
                            console.log(`âœ… Loaded existing image ${index + 1} for variant ${variant.sku}`);
                        }
                    });
                    console.log(`âœ… Loaded ${tableVariantImages.length} existing images for editing`);
                } else {
                    console.log('â„¹ï¸ No existing images found for this variant');
                }
                
                // Show the modal
                modal.style.display = 'block';
                console.log('âœ… Variant edit modal opened');
            }
            
            // Function to delete an existing variant
            function deleteVariant(variantId) {
                console.log('ğŸ—‘ï¸ deleteVariant called with variantId:', variantId);
                
                // Prevent any form submission
                if (event) {
                    event.preventDefault();
                    event.stopPropagation();
                }
                
                // Find variant by ID instead of array index
                const variant = window.existingVariants.find(v => v.id == variantId);
                if (!variant) {
                    console.error('âŒ Variant not found with ID:', variantId);
                    alert('Ù†ÙˆØ¹ Ù…Ø­ØµÙˆÙ„ Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯');
                    return;
                }
                
                const variantIndex = window.existingVariants.findIndex(v => v.id == variantId);
                const wasDefault = variant.is_default;
                
                if (confirm(`Ø¢ÛŒØ§ Ù…Ø·Ù…Ø¦Ù† Ù‡Ø³ØªÛŒØ¯ Ú©Ù‡ Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒØ¯ Ù†ÙˆØ¹ Ù…Ø­ØµÙˆÙ„ "${variant.sku}" Ø±Ø§ Ø­Ø°Ù Ú©Ù†ÛŒØ¯ØŸ`)) {
                    // Remove variant from the array
                    window.existingVariants.splice(variantIndex, 1);
                    
                    // Reload the variants table
                    loadExistingVariants();
                    
                    console.log('âœ… Variant deleted:', variant.sku);
                }
            }
            
            // Make functions globally accessible
            window.editVariant = editVariant;
            window.editVariantFromTable = editVariantFromTable;
            window.deleteVariant = deleteVariant;
            
            // Also make sure editVariantFromTable is accessible for inline onclick
            window.editVariantFromTable = editVariantFromTable;
            
            // Simple form submission prevention for variant buttons
            const productForm = document.getElementById('product_form');
            if (productForm) {
                productForm.addEventListener('submit', function(event) {
                    // Check if the submit was triggered by a variant button
                    const activeElement = document.activeElement;
                    if (activeElement && (
                        activeElement.textContent === 'ÙˆÛŒØ±Ø§ÛŒØ´' ||
                        activeElement.textContent === 'Ø­Ø°Ù' ||
                        activeElement.getAttribute('onclick')?.includes('editVariantFromTable') ||
                        activeElement.getAttribute('onclick')?.includes('editVariant') ||
                        activeElement.getAttribute('onmousedown')?.includes('editVariant')
                    )) {
                        console.log('ğŸš« Prevented form submission from variant button');
                        event.preventDefault();
                        event.stopPropagation();
                        return false;
                    }
                });
            }
            
            
            // Initialize category change listener
            console.log('ğŸ” DEBUG: Looking for category select element...');
            const categorySelect = document.getElementById('id_category');
            console.log('ğŸ” DEBUG: categorySelect element:', categorySelect);
            console.log('ğŸ” DEBUG: categorySelect exists:', !!categorySelect);
            
            if (categorySelect) {
                console.log('âœ… Category select element found!');
                console.log('âœ… Current value:', categorySelect.value);
                console.log('âœ… All options:', Array.from(categorySelect.options).map(o => ({ value: o.value, text: o.text })));
                
                categorySelect.addEventListener('change', function() {
                    console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
                    console.log('â•‘ ğŸ”„ CATEGORY CHANGE EVENT TRIGGERED                â•‘');
                    console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                    console.log('ğŸ”„ New category value:', this.value);
                    console.log('ğŸ”„ Value type:', typeof this.value);
                    console.log('ğŸ”„ Selected option text:', this.options[this.selectedIndex]?.text);
                    console.log('ğŸ”„ window.categoryAttributes exists:', !!window.categoryAttributes);
                    console.log('ğŸ”„ window.categoryAttributes type:', typeof window.categoryAttributes);
                    
                    if (window.categoryAttributes) {
                        console.log('ğŸ”„ Available category IDs:', Object.keys(window.categoryAttributes));
                        console.log('ğŸ”„ Total categories with attributes:', Object.keys(window.categoryAttributes).length);
                    }
                    
                    if (this.value) {
                        console.log('âœ… Category value is not empty, calling loadCategoryAttributes...');
                        window.loadCategoryAttributes(this.value);
                    } else {
                        console.log('âš ï¸ Category value is empty, showing empty state');
                        // Clear attributes if no category selected
                        const attributesContainer = document.getElementById('attributes-container');
                        if (attributesContainer) {
                            attributesContainer.innerHTML = `
                                <div class="empty-state">
                                    <p>Ø§Ø¨ØªØ¯Ø§ ÛŒÚ© Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯</p>
                                </div>
                            `;
                        }
                    }
                });
                
                // If a category is already selected, load its attributes
                if (categorySelect.value) {
                    console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
                    console.log('â•‘ ğŸ”„ LOADING PRE-SELECTED CATEGORY ON PAGE LOAD     â•‘');
                    console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                    console.log('ğŸ”„ Pre-selected category ID:', categorySelect.value);
                    console.log('ğŸ”„ Pre-selected category text:', categorySelect.options[categorySelect.selectedIndex]?.text);
                    console.log('ğŸ”„ Calling loadCategoryAttributes...');
                    window.loadCategoryAttributes(categorySelect.value);
                    
                    // If there are existing variants, auto-select their attributes first
                    if (window.existingVariants && window.existingVariants.length > 0) {
                        console.log('ğŸ”„ Found existing variants, auto-selecting attributes first...');
                        setTimeout(() => {
                            autoSelectVariantAttributes();
                            // Then refresh main attributes to hide variant attributes
                            setTimeout(() => {
                                window.loadCategoryAttributes(categorySelect.value);
                                console.log('âœ… Main attributes refreshed after auto-selection on page load');
                            }, 300);
                        }, 100);
                    }
                } else {
                    // Show initial empty state
                    const attributesContainer = document.getElementById('attributes-container');
                    if (attributesContainer) {
                        attributesContainer.innerHTML = `
                            <div class="empty-state">
                                <p>Ø§Ø¨ØªØ¯Ø§ ÛŒÚ© Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯</p>
                            </div>
                        `;
                    }
                }
            } else {
                console.log('âŒ Category select element not found!');
            }
        });
        
        // CROP FUNCTIONALITY
        let cropperInstance = null;
        let currentImageElement = null;
        let currentPreviewElement = null;
        
        // Function to open crop modal
        function openCropModal(imageSrc, previewElement) {
            console.log('ğŸ”§ Opening crop modal for image:', imageSrc);
            
            const modal = document.getElementById('cropModal');
            const cropImage = document.getElementById('cropImage');
            
            if (!modal || !cropImage) {
                console.error('âŒ Crop modal elements not found');
                return;
            }
            
            // Store references
            currentImageElement = cropImage;
            currentPreviewElement = previewElement;
            
            // Set image source
            cropImage.src = imageSrc;
            
            // Show modal
            modal.style.display = 'block';
            
            // Initialize cropper after image loads
            cropImage.onload = function() {
                // Destroy existing cropper if any
                if (cropperInstance) {
                    cropperInstance.destroy();
                }
                
                // Initialize new cropper
                cropperInstance = new Cropper(cropImage, {
                    aspectRatio: NaN, // Free aspect ratio
                    viewMode: 1,
                    dragMode: 'move',
                    autoCropArea: 0.8,
                    restore: false,
                    guides: true,
                    center: true,
                    highlight: true,
                    cropBoxMovable: true,
                    cropBoxResizable: true,
                    toggleDragModeOnDblclick: false,
                    background: false,
                    responsive: true,
                    checkCrossOrigin: false,
                    checkOrientation: false,
                    modal: true,
                    guides: true,
                    center: true,
                    highlight: true,
                    background: false,
                    autoCropArea: 0.8,
                    viewMode: 1,
                    dragMode: 'move',
                    cropBoxMovable: true,
                    cropBoxResizable: true,
                    toggleDragModeOnDblclick: false,
                    responsive: true,
                    checkCrossOrigin: false,
                    checkOrientation: false,
                    modal: true
                });
                
                console.log('âœ… Cropper initialized');
            };
        }
        
        // Function to close crop modal
        function closeCropModal() {
            console.log('ğŸ”§ Closing crop modal');
            
            const modal = document.getElementById('cropModal');
            if (modal) {
                modal.style.display = 'none';
            }
            
            // Destroy cropper instance
            if (cropperInstance) {
                cropperInstance.destroy();
                cropperInstance = null;
            }
            
            // Clear references
            currentImageElement = null;
            currentPreviewElement = null;
        }
        
        // Function to save cropped image
        function saveCroppedImage() {
            console.log('ğŸ”§ Saving cropped image');
            
            if (!cropperInstance || !currentPreviewElement) {
                console.error('âŒ No cropper instance or preview element');
                return;
            }
            
            try {
                // Get cropped canvas
                const canvas = cropperInstance.getCroppedCanvas({
                    width: 800,
                    height: 600,
                    minWidth: 256,
                    minHeight: 256,
                    maxWidth: 2048,
                    maxHeight: 2048,
                    fillColor: '#fff',
                    imageSmoothingEnabled: true,
                    imageSmoothingQuality: 'high',
                });
                
                if (!canvas) {
                    console.error('âŒ Failed to get cropped canvas');
                    alert('Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±Ø´ ØªØµÙˆÛŒØ±. Ù„Ø·ÙØ§ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯.');
                    return;
                }
                
                // Convert canvas to blob
                canvas.toBlob(function(blob) {
                    if (!blob) {
                        console.error('âŒ Failed to create blob from canvas');
                        alert('Ø®Ø·Ø§ Ø¯Ø± Ø°Ø®ÛŒØ±Ù‡ ØªØµÙˆÛŒØ± Ø¨Ø±Ø´ Ø®ÙˆØ±Ø¯Ù‡.');
                        return;
                    }
                    
                    console.log('ğŸ“¦ Cropped blob created:', blob.size, 'bytes');
                    
                    // âœ¨ CRITICAL: Convert blob to File object so it can be submitted with the form
                    const timestamp = new Date().getTime();
                    const filename = `cropped_image_${timestamp}.jpg`;
                    const croppedFile = new File([blob], filename, {
                        type: 'image/jpeg',
                        lastModified: Date.now()
                    });
                    
                    console.log('ğŸ“ Cropped file created:', croppedFile.name, croppedFile.size, 'bytes');
                    
                    // âœ¨ CRITICAL: Store the cropped file on the preview element
                    // This will be used during form submission to replace the original file
                    currentPreviewElement.setAttribute('data-cropped-file-name', filename);
                    currentPreviewElement.dataset.croppedFile = 'true'; // Mark as cropped
                    
                    // Store the File object in a way that can be retrieved during form submission
                    // We'll store it in a Map keyed by preview element
                    if (!window.croppedFilesMap) {
                        window.croppedFilesMap = new Map();
                    }
                    window.croppedFilesMap.set(currentPreviewElement, croppedFile);
                    
                    console.log('âœ… Cropped file stored in map for preview element');
                    
                    // Create new image element with cropped image
                    const newImg = document.createElement('img');
                    newImg.src = URL.createObjectURL(blob);
                    newImg.style.cssText = `
                        display: block;
                        width: 150px;
                        height: 150px;
                        object-fit: cover;
                        pointer-events: none;
                    `;
                    
                    // Replace the image in the preview element
                    const oldImg = currentPreviewElement.querySelector('img');
                    if (oldImg) {
                        // Clean up old image URL
                        if (oldImg.src.startsWith('blob:')) {
                            URL.revokeObjectURL(oldImg.src);
                        }
                        currentPreviewElement.replaceChild(newImg, oldImg);
                    }
                    
                    console.log('âœ… Cropped image saved and replaced in preview');
                    console.log('ğŸ’¡ The cropped file will be used when submitting the form');
                    
                    // Close modal
                    closeCropModal();
                    
                    // Show success message
                    showNotification('ØªØµÙˆÛŒØ± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ø±Ø´ Ø¯Ø§Ø¯Ù‡ Ø´Ø¯ Ùˆ Ù‡Ù†Ú¯Ø§Ù… Ø°Ø®ÛŒØ±Ù‡ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø®ÙˆØ§Ù‡Ø¯ Ø´Ø¯', 'success');
                    
                }, 'image/jpeg', 0.9);
                
            } catch (error) {
                console.error('âŒ Error saving cropped image:', error);
                alert('Ø®Ø·Ø§ Ø¯Ø± Ø°Ø®ÛŒØ±Ù‡ ØªØµÙˆÛŒØ± Ø¨Ø±Ø´ Ø®ÙˆØ±Ø¯Ù‡: ' + error.message);
            }
        }
        
        // Function to show notification
        function showNotification(message, type = 'info') {
            // Create notification element
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${type === 'success' ? '#4CAF50' : type === 'error' ? '#f44336' : '#2196F3'};
                color: white;
                padding: 15px 20px;
                border-radius: 4px;
                box-shadow: 0 4px 8px rgba(0,0,0,0.2);
                z-index: 3000;
                font-size: 14px;
                max-width: 300px;
                word-wrap: break-word;
            `;
            notification.textContent = message;
            
            // Add to page
            document.body.appendChild(notification);
            
            // Remove after 3 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 3000);
        }
        
        // Make crop functions global
        window.openCropModal = openCropModal;
        window.closeCropModal = closeCropModal;
        window.saveCroppedImage = saveCroppedImage;
        
        // Show success notification if there are success messages
        document.addEventListener('DOMContentLoaded', function() {
            const successMessages = document.querySelectorAll('.alert-success');
            if (successMessages.length > 0) {
                // Show notification using the existing showNotification function
                if (typeof showNotification === 'function') {
                    showNotification('Ù…Ø­ØµÙˆÙ„ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯ âœ…', 'success');
                } else {
                    // Fallback notification
                    const notification = document.getElementById('save-notification');
                    if (notification) {
                        notification.style.display = 'block';
                        setTimeout(() => {
                            notification.style.display = 'none';
                        }, 3000);
                    }
                }
            }
        });
        
        // Function to enable existing drag and drop for variant modal
        function enableExistingDragDropForVariant(container) {
            if (!container) {
                console.log('âŒ Variant container not found');
                return;
            }

            console.log('âœ… Enabling existing drag and drop for variant modal');

            // Make sure the existing drag and drop functions work with this container
            // The existing functions (handleDragOver, handleDrop, etc.) already exist
            // We just need to make sure they work with the variant modal's container

            // Initialize drag and drop for the variant container
            container.addEventListener('dragover', handleDragOver);
            container.addEventListener('drop', handleDrop);
            container.addEventListener('dragenter', handleDragEnter);
            container.addEventListener('dragleave', handleDragLeave);

            console.log('âœ… Variant drag and drop enabled using existing functions');
        }

        console.log('âœ… All magnificent functionality restored!');
    </script>

    <!-- VARIANT MODAL - POSITIONED OUTSIDE ALL CONTAINERS FOR FULL SCREEN ACCESS -->
    <div class="variant-modal" id="variantModal" style="display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.8); z-index: 10000; overflow-y: auto;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 25px; border-radius: 12px; width: 500px; max-width: 90vw; max-height: 90vh; overflow-y: auto; box-shadow: 0 25px 80px rgba(0,0,0,0.4); border: 1px solid #ddd;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px; border-bottom: 2px solid #f0f0f0; padding-bottom: 15px;">
                <h3 id="variantModalTitle" style="margin: 0; color: #333; font-size: 1.5rem; font-weight: bold;">Ø§ÙØ²ÙˆØ¯Ù† Ù†ÙˆØ¹ Ù…Ø­ØµÙˆÙ„ Ø¬Ø¯ÛŒØ¯</h3>
                <button type="button" onclick="closeVariantModal();" style="background: none; border: none; font-size: 28px; cursor: pointer; color: #666; padding: 8px; border-radius: 50%; transition: all 0.3s; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center;" onmouseover="this.style.background='#f0f0f0'; this.style.color='#333'" onmouseout="this.style.background='none'; this.style.color='#666'">&times;</button>
            </div>
            <form id="variantForm">
                {% csrf_token %}
                <input type="hidden" id="variantIndex" value="">
                
                <div style="margin-bottom: 20px;">
                    <label for="variantSku" style="display: block; margin-bottom: 6px; font-weight: bold; color: #333; font-size: 14px;">Ú©Ø¯ Ù…Ø­ØµÙˆÙ„ (SKU)</label>
                    <input type="text" id="variantSku" style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px; transition: all 0.3s;" required onfocus="this.style.borderColor='#007bff'; this.style.boxShadow='0 0 0 3px rgba(0,123,255,0.1)'" onblur="this.style.borderColor='#ddd'; this.style.boxShadow='none'">
                </div>
                
                <div id="variantAttributesForm" style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border: 1px solid #e9ecef;">
                    <p style="color: #6c757d; text-align: center; padding: 0.5rem; margin: 0; font-size: 13px;">
                        Ø§Ø¨ØªØ¯Ø§ ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ù…ØªØºÛŒØ± Ø±Ø§ Ø§Ø² Ø¨Ø§Ù„Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯
                    </p>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                    <div>
                        <label for="variantPriceToman" style="display: block; margin-bottom: 6px; font-weight: bold; color: #333; font-size: 14px;">Ù‚ÛŒÙ…Øª (ØªÙˆÙ…Ø§Ù†)</label>
                        <input type="text" id="variantPriceToman" style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px; transition: all 0.3s;" placeholder="Ø®Ø§Ù„ÛŒ Ø¨Ú¯Ø°Ø§Ø±ÛŒØ¯ ØªØ§ Ø§Ø² Ù‚ÛŒÙ…Øª Ø§ØµÙ„ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø´ÙˆØ¯" onfocus="this.style.borderColor='#007bff'; this.style.boxShadow='0 0 0 3px rgba(0,123,255,0.1)'" onblur="this.style.borderColor='#ddd'; this.style.boxShadow='none'">
                    </div>
                    
                    <div>
                        <label for="variantStock" style="display: block; margin-bottom: 6px; font-weight: bold; color: #333; font-size: 14px;">Ù…ÙˆØ¬ÙˆØ¯ÛŒ</label>
                        <input type="number" id="variantStock" style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px; transition: all 0.3s;" min="0" required onfocus="this.style.borderColor='#007bff'; this.style.boxShadow='0 0 0 3px rgba(0,123,255,0.1)'" onblur="this.style.borderColor='#ddd'; this.style.boxShadow='none'">
                    </div>
                </div>
                
                <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; text-align: center;">
                    <label style="display: inline-flex; align-items: center; gap: 10px; cursor: pointer; font-weight: bold; color: #333; font-size: 14px;">
                        <input type="checkbox" id="variantIsActive" checked style="transform: scale(1.2); accent-color: #28a745;">
                        ÙØ¹Ø§Ù„
                    </label>
                </div>
                
                <div style="margin-bottom: 20px; padding: 15px; background: #fff3cd; border-radius: 8px; text-align: center; border: 1px solid #ffeaa7;">
                    <label style="display: inline-flex; align-items: center; gap: 10px; cursor: pointer; font-weight: bold; color: #856404; font-size: 14px;">
                        <input type="checkbox" id="variantIsDefault" style="transform: scale(1.2); accent-color: #ffc107;">
                        ØªØ±Ú©ÛŒØ¨ Ù¾ÛŒØ´â€ŒÙØ±Ø¶
                    </label>
                    <p style="color: #856404; font-size: 12px; margin: 5px 0 0 0;">Ø§ÛŒÙ† ØªØ±Ú©ÛŒØ¨ Ø¨Ù‡ ØµÙˆØ±Øª Ù¾ÛŒØ´â€ŒÙØ±Ø¶ Ù†Ù…Ø§ÛŒØ´ Ø¯Ø§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯</p>
                </div>
                
                <!-- Use existing main form upload area with drag and drop -->
                <div class="image-section">
                    <label style="color: #000; font-weight: bold; font-size: 14px;">ØªØµØ§ÙˆÛŒØ± Ø§ØµÙ„ÛŒ Ù…Ø­ØµÙˆÙ„</label>
                    <p class="form-text" id="variantImageDescription" style="color: #000; font-size: 13px; margin: 5px 0;">ØªØµØ§ÙˆÛŒØ±ÛŒ Ú©Ù‡ Ø¨Ø±Ø§ÛŒ Ù‡Ù…Ù‡ Ø§Ù†ÙˆØ§Ø¹ Ù…Ø­ØµÙˆÙ„ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯</p>

                    <!-- Use main form's upload area -->
                    <div style="width: 100%; text-align: center; padding: 2rem;">
                        <input type="file" id="variantImageInput" name="variant_images" multiple accept="image/*" style="display: none;">
                        <div class="upload-area" style="border: 3px dashed #4a5568; border-radius: 8px; padding: 2rem 3rem; background: #2d3748; cursor: pointer; width: 100%; margin: 0 auto; position: relative;"
                             onclick="console.log('ğŸ–±ï¸ Variant upload area clicked'); const input = document.getElementById('variantImageInput'); console.log('ğŸ” Variant input found:', !!input); console.log('ğŸ” Variant input disabled:', input ? input.disabled : 'N/A'); if (input && !input.disabled) { input.click(); } else { console.error('âŒ Cannot click variant input - not found or disabled'); }">
                            <p style="font-size: 1rem; margin-bottom: 1rem; color: #e2e8f0;">Ø¨Ø±Ø§ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ ØªØµØ§ÙˆÛŒØ± Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯ ÛŒØ§ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ Ø±Ø§ Ø§ÛŒÙ†Ø¬Ø§ Ø¨Ú©Ø´ÛŒØ¯</p>
                            <button type="button" style="background: #3182ce; color: white; border: none; padding: 0.8rem 1.5rem; border-radius: 4px; cursor: pointer; font-size: 0.9rem;" onclick="event.stopPropagation(); console.log('ğŸ–±ï¸ Variant upload button clicked'); const input = document.getElementById('variantImageInput'); console.log('ğŸ” Variant input found:', !!input); console.log('ğŸ” Variant input disabled:', input ? input.disabled : 'N/A'); if (input && !input.disabled) { input.click(); } else { console.error('âŒ Cannot click variant input - not found or disabled'); }">Ø§Ù†ØªØ®Ø§Ø¨ ÙØ§ÛŒÙ„</button>
                        </div>
                    </div>

                    <!-- Use main form's image preview area -->
                    <div class="image-preview" id="variantImagePreviews"></div>
                </div>
                
            </form>
            <div style="display: flex; gap: 15px; justify-content: flex-end; margin-top: 25px; padding-top: 20px; border-top: 2px solid #f0f0f0;">
                <button type="button" onclick="closeVariantModal();" style="padding: 10px 20px; border: 2px solid #6c757d; background: white; color: #6c757d; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 14px; transition: all 0.3s;" onmouseover="this.style.background='#6c757d'; this.style.color='white'; this.style.transform='translateY(-1px)'" onmouseout="this.style.background='white'; this.style.color='#6c757d'; this.style.transform='translateY(0)'">Ø§Ù†ØµØ±Ø§Ù</button>
                <button type="button" onclick="saveVariant()" style="padding: 10px 20px; background: #28a745; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 14px; transition: all 0.3s; box-shadow: 0 4px 15px rgba(40, 167, 69, 0.3);" onmouseover="this.style.background='#218838'; this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(40, 167, 69, 0.4)'" onmouseout="this.style.background='#28a745'; this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(40, 167, 69, 0.3)'">âœ… Ø°Ø®ÛŒØ±Ù‡ Ù…Ø­ØµÙˆÙ„</button>
            </div>
        </div>
    </div>

</body>
</html>
